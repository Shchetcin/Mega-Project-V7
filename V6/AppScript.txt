// ================= КОНФИГУРАЦИЯ =================
const CONFIG = {
  SHEET_ID: '1Qv9eq2gs4s1zG_23PXCElrCAL1P7aTLRUDtQH0qaNd8', // замените на свой
  ADMIN_PASSWORD: 'org2026',
  VERSION: '6.15 (итоговая)'
};

// ================= ИНИЦИАЛИЗАЦИЯ ТАБЛИЦ =================
function getSpreadsheet() {
  if (!CONFIG.SHEET_ID) throw new Error('Установите SHEET_ID');
  const ss = SpreadsheetApp.openById(CONFIG.SHEET_ID);
  initializeSheets(ss);
  return ss;
}

function initializeSheets(ss) {
  // Лист команд
  let teamsSheet = ss.getSheetByName('teams');
  if (!teamsSheet) {
    teamsSheet = ss.insertSheet('teams');
    teamsSheet.appendRow([
      'ID', 'Название команды', 'Импульсы', 'Код доступа', 'Контакт',
      'Инвестиции', 'Кредит', 'Жетоны', 'Контракт ID', 'Контракт выполнен',
      'Энергослоты', 'Колонисты', 'Запас еды', 'Индекс терраформинга',
      'Взнос тотема (номинал)', 'Всего взносов тотема', 'Текущее событие', 'Длительность события',
      'Коэффициент красоты', 'Эпоха последнего взноса в тотем'
    ]);
  } else {
    const headers = teamsSheet.getRange(1, 1, 1, teamsSheet.getLastColumn()).getValues()[0];
    const requiredCols = [
      'Энергослоты', 'Колонисты', 'Запас еды', 'Индекс терраформинга',
      'Взнос тотема (номинал)', 'Всего взносов тотема', 'Текущее событие', 'Длительность события',
      'Коэффициент красоты', 'Эпоха последнего взноса в тотем'
    ];
    requiredCols.forEach(col => {
      if (!headers.includes(col)) {
        const lastCol = teamsSheet.getLastColumn() + 1;
        teamsSheet.getRange(1, lastCol).setValue(col);
        if (teamsSheet.getLastRow() > 1) {
          const range = teamsSheet.getRange(2, lastCol, teamsSheet.getLastRow() - 1);
          if (col.includes('Индекс')) range.setValue(50);
          else if (col.includes('Коэффициент')) range.setValue(1.0);
          else range.setValue(0);
        }
      }
    });
  }

  // Лист товаров
  let itemsSheet = ss.getSheetByName('items');
  if (!itemsSheet) {
    itemsSheet = ss.insertSheet('items');
    itemsSheet.appendRow([
      'ID', 'Название', 'Описание', 'Цена', 'Иконка', 'Тип',
      'Энергия дает', 'Энергия потребляет', 'Колонисты дает', 'Еда дает',
      'Бонус терраформинга', 'Производство (доход)', 'Уникальное', 'Макс на команду',
      'Эффект (JSON)'
    ]);
    populateItems(itemsSheet);
  } else {
    const headers = itemsSheet.getRange(1, 1, 1, itemsSheet.getLastColumn()).getValues()[0];
    const requiredCols = [
      'Энергия дает', 'Энергия потребляет', 'Колонисты дает', 'Еда дает',
      'Бонус терраформинга', 'Производство (доход)', 'Уникальное', 'Макс на команду'
    ];
    requiredCols.forEach(col => {
      if (!headers.includes(col)) {
        const lastCol = itemsSheet.getLastColumn() + 1;
        itemsSheet.getRange(1, lastCol).setValue(col);
        if (itemsSheet.getLastRow() > 1) {
          itemsSheet.getRange(2, lastCol, itemsSheet.getLastRow() - 1).setValue(0);
        }
      }
    });
  }

  // Лист покупок
  if (!ss.getSheetByName('purchases')) {
    const sheet = ss.insertSheet('purchases');
    sheet.appendRow(['ID', 'ID команды', 'ID товара', 'Дата', 'Цена', 'Статус']);
  } else {
    const sheet = ss.getSheetByName('purchases');
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    if (!headers.includes('Статус')) {
      const lastCol = sheet.getLastColumn() + 1;
      sheet.getRange(1, lastCol).setValue('Статус');
      if (sheet.getLastRow() > 1) {
        sheet.getRange(2, lastCol, sheet.getLastRow() - 1).setValue('функционирует');
      }
    }
  }

  // Лист транзакций
  if (!ss.getSheetByName('transactions')) {
    const sheet = ss.insertSheet('transactions');
    sheet.appendRow(['Время', 'ID команды', 'Импульсы', 'Причина', 'Кто начислил']);
  }

  // Лист контрактов
  if (!ss.getSheetByName('contracts')) {
    const sheet = ss.insertSheet('contracts');
    sheet.appendRow(['ID', 'Описание', 'Условие (JSON)', 'Награда', 'Активен']);
  }

  // Лист событий колеса фортуны
  if (!ss.getSheetByName('events')) {
    const sheet = ss.insertSheet('events');
    sheet.appendRow(['ID', 'Название', 'Тип (positive/negative)', 'Описание', 'Эффект (JSON)']);
    const defaultEvents = [
      [1, 'Солнечная активность', 'positive', 'Добыча +10% (с панелью +15%)', '{"type":"incomeBoost","target":"добыча","value":0.1,"extra":{"hasSolarPanel":0.15}}'],
      [2, 'Рынок услуг колонии', 'positive', 'Производство +10%', '{"type":"incomeBoost","target":"производство","value":0.1}'],
      [3, 'Грант Академии', 'positive', '+80 импульсов сразу', '{"type":"direct","value":80}'],
      [4, 'Стабильное питание', 'positive', 'Улучшение еды на ступень', '{"type":"foodBoost","value":1}'],
      [5, 'Инженерный апгрейд', 'positive', '+2 слота энергии', '{"type":"energyBoost","value":2}'],
      [6, 'Метеоритный дождь', 'negative', '-10% доход (щит защищает)', '{"type":"incomeMalus","value":-0.1,"negate":{"shield":true}}'],
      [7, 'Сбой энергосети', 'negative', '-2 слота энергии (батареи защищают)', '{"type":"energyMalus","value":-2,"negate":{"batteries":true}}'],
      [8, 'Штраф Совета миссии', 'negative', '-60 импульсов (космопорт уменьшает вдвое)', '{"type":"direct","value":-60,"half":{"hasKosmoPort":true}}'],
      [9, 'Забастовка техников', 'negative', 'r ×0.9 (медмодуль защищает)', '{"type":"staffMalus","value":0.9,"negate":{"medModule":true}}'],
      [10, 'Пыльная буря', 'negative', '-5% терраформинга (атмосфера защищает)', '{"type":"terraformMalus","value":-5,"negate":{"atmosphere":true}}']
    ];
    defaultEvents.forEach(row => sheet.appendRow(row));
  }

  // Лист состояния игры (эпохи)
  if (!ss.getSheetByName('game_state')) {
    const sheet = ss.insertSheet('game_state');
    sheet.appendRow(['Параметр', 'Значение']);
    sheet.appendRow(['current_epoch', 0]);
    sheet.appendRow(['epoch_name', 'Заря']);
  }
}

function populateItems(sheet) {
  const items = [
    // Сезон 1
    [1, 'Жилой комплекс "Альфа"', 'Обеспечивает жильём колонистов', 27, 'fa-solid fa-house-chimney', 'жильё', 0, 0, 200, 0, 0, false, false, 0, '{}'],
    [2, 'Солнечная панель', 'Даёт энергию', 27, 'fa-solid fa-solar-panel', 'энергия', 3, 0, 0, 0, 0, false, false, 0, '{}'],
    [3, 'Рудная шахта', 'Добывает руду', 81, 'fa-solid fa-cube', 'добыча', 0, 1, 0, 0, -2, true, false, 0, '{"income":140}'],
    [4, 'Станция еды', 'Производит еду', 40, 'fa-solid fa-utensils', 'еда', 0, 1, 0, 300, 0, false, false, 0, '{}'],
    [5, 'Терраформер', 'Улучшает терраформинг', 63, 'fa-solid fa-leaf', 'терраформинг', 0, 0, 0, 0, 3, false, false, 0, '{}'],
    [6, 'Жилой комплекс "Бета"', 'Обеспечивает жильём колонистов', 27, 'fa-solid fa-house-chimney', 'жильё', 0, 0, 200, 0, 0, false, false, 0, '{}'],
    // Сезон 2
    [7, 'Ледяной бур', 'Добыча воды', 67, 'fa-solid fa-water', 'добыча', 0, 1, 0, 0, -2, true, false, 0, '{"income":115}'],
    [8, 'Обогатитель руды', 'Увеличивает доход шахт', 72, 'fa-solid fa-industry', 'бустер', 0, 1, 0, 0, 0, false, true, 1, '{"boostType":"добыча","value":0.25}'],
    [9, 'Бустер электроэнергии', 'Дополнительная энергия', 36, 'fa-solid fa-bolt', 'энергия', 2, 0, 0, 0, 0, false, false, 0, '{}'],
    [10, 'Тотем колонии', 'Особое здание', 22, 'fa-solid fa-feather', 'тотем', 0, 0, 0, 0, 0, false, true, 1, '{}'],
    [11, 'Жилой модуль "Гамма"', 'Жильё для специалистов', 27, 'fa-solid fa-house', 'жильё', 0, 0, 200, 0, 0, false, false, 0, '{}'],
    // Сезон 3
    [12, 'Завод 3D-печати', 'Производство деталей', 108, 'fa-solid fa-cubes', 'производство', 0, 1, 0, 0, -2, true, true, 1, '{"income":170}'],
    [13, 'Логистический хаб', 'Ускоряет добычу', 85, 'fa-solid fa-truck', 'бустер', 0, 1, 0, 0, 0, false, true, 1, '{"boostType":"добыча","value":0.1}'],
    [14, 'Центр обучения', 'Снижает потребность в персонале', 99, 'fa-solid fa-graduation-cap', 'бустер', 0, 1, 0, 0, 0, false, true, 1, '{"staffFactor":0.85}'],
    [15, 'Космический щит', 'Защита от метеоритов', 99, 'fa-solid fa-shield-halved', 'защита', 0, 0, 0, 0, 0, false, true, 1, '{"shield":true}'],
    // Сезон 4
    [16, 'АЭС', 'Мощный источник энергии', 162, 'fa-solid fa-atom', 'энергия', 10, 0, 0, 0, 0, false, true, 1, '{}'],
    [17, 'Гелиевый сборщик', 'Добыча гелия-3', 144, 'fa-solid fa-gas-pump', 'добыча', 0, 1, 0, 0, -2, true, true, 2, '{"income":260}'],
    [18, 'Станция атмосферы', 'Улучшает терраформинг', 171, 'fa-solid fa-wind', 'терраформинг', 0, 0, 0, 0, 7, false, true, 1, '{}'],
    [19, 'Медицинский модуль', 'Защита от забастовок', 81, 'fa-solid fa-hospital', 'защита', 0, 0, 0, 0, 0, false, true, 1, '{"medModule":true}'],
    // Сезон 5
    [20, 'Институт озеленения', 'Сильный терраформер', 216, 'fa-solid fa-seedling', 'терраформинг', 0, 0, 0, 0, 10, false, true, 1, '{}'],
    [21, 'Туристический купол', 'Доход от туризма', 126, 'fa-solid fa-umbrella-beach', 'производство', 0, 1, 0, 0, -2, true, true, 2, '{"income":120,"incomeHigh":170,"terraformReq":70,"terraformHigh":70}'],
    [22, 'Лаборатория инноваций', 'Научный доход', 135, 'fa-solid fa-flask', 'производство', 0, 1, 0, 0, -2, true, true, 1, '{"income":150}'],
    [23, 'Нанофильтры очистки', 'Очистка атмосферы', 126, 'fa-solid fa-filter', 'терраформинг', 0, 0, 0, 0, 5, false, true, 1, '{}'],
    // Сезон 6
    [24, 'Орбитальный лифт', 'Космический транспорт', 288, 'fa-solid fa-elevator', 'производство', 0, 1, 0, 0, -2, true, true, 1, '{"income":420}'],
    [25, 'Резервные батареи', 'Защита от сбоя сети', 72, 'fa-solid fa-battery-full', 'защита', 0, 0, 0, 0, 0, false, true, 1, '{"batteries":true}'],
    [26, 'Дроны-ремонтники', 'Ускоряют производство', 85, 'fa-solid fa-robot', 'бустер', 0, 1, 0, 0, 0, false, true, 1, '{"boostType":"производство","value":0.1}'],
    [27, 'Космопорт', 'Торговый порт', 198, 'fa-solid fa-rocket', 'производство', 0, 1, 0, 0, -2, true, true, 1, '{"income":300}'],
    // Разведывательный пункт
    [28, 'Разведывательный пункт', 'Позволяет видеть рейтинг команд', 50, 'fa-solid fa-satellite-dish', 'специальное', 0, 0, 0, 0, 0, false, true, 1, '{"revealRating":true}'],
    // Новые жилые дома
    [29, 'Жилой комплекс "Дельта"', 'Комфортное жильё', 27, 'fa-solid fa-house-chimney', 'жильё', 0, 0, 200, 0, 0, false, false, 0, '{}'],
    [30, 'Жилой модуль "Эпсилон"', 'Модульное жильё', 27, 'fa-solid fa-house', 'жильё', 0, 0, 200, 0, 0, false, false, 0, '{}'],
    [31, 'Жилой квартал "Дзета"', 'Квартал для семей', 27, 'fa-solid fa-city', 'жильё', 0, 0, 200, 0, 0, false, false, 0, '{}'],
    [32, 'Жилой комплекс "Эта"', 'Премиум жильё', 27, 'fa-solid fa-building', 'жильё', 0, 0, 200, 0, 0, false, false, 0, '{}'],
    [33, 'Жилой модуль "Тета"', 'Экспериментальное жильё', 27, 'fa-solid fa-igloo', 'жильё', 0, 0, 200, 0, 0, false, false, 0, '{}']
  ];
  items.forEach(row => sheet.appendRow(row));
}

// ================= ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ =================
function createResponse(data, statusCode = 200) {
  return ContentService.createTextOutput(JSON.stringify({
    success: statusCode === 200,
    data: data,
    timestamp: new Date().toISOString(),
    version: CONFIG.VERSION
  })).setMimeType(ContentService.MimeType.JSON);
}

function logTransaction(ss, teamId, points, reason, moderator = 'Система') {
  const transSheet = ss.getSheetByName('transactions');
  transSheet.appendRow([new Date(), teamId, points, reason, moderator]);
}

function updateTeamScore(ss, teamId, delta, reason, moderator = 'Система') {
  const teamsSheet = ss.getSheetByName('teams');
  const teamsData = teamsSheet.getDataRange().getValues();
  for (let i = 1; i < teamsData.length; i++) {
    if (teamsData[i][0] == teamId) {
      const current = parseFloat(teamsData[i][2]) || 0;
      const newScore = current + delta;
      teamsSheet.getRange(i + 1, 3).setValue(newScore);
      logTransaction(ss, teamId, delta, reason, moderator);
      return newScore;
    }
  }
  return null;
}

function getFunctionalBuildings(teamId, ss) {
  const purchasesSheet = ss.getSheetByName('purchases');
  const purchasesData = purchasesSheet.getDataRange().getValues();
  const statusCol = purchasesSheet.getLastColumn();
  const itemsSheet = ss.getSheetByName('items');
  const itemsData = itemsSheet.getDataRange().getValues();
  const itemsHeaders = itemsSheet.getRange(1, 1, 1, itemsSheet.getLastColumn()).getValues()[0];

  const buildings = [];
  for (let i = 1; i < purchasesData.length; i++) {
    if (purchasesData[i][1] == teamId && purchasesData[i][statusCol - 1] === 'функционирует') {
      const itemId = purchasesData[i][2];
      for (let j = 1; j < itemsData.length; j++) {
        if (itemsData[j][0] == itemId) {
          const b = {
            purchaseId: purchasesData[i][0],
            itemId: itemId,
            name: itemsData[j][1],
            type: itemsData[j][5],
            energyProvides: 0,
            energyCost: 0,
            colonistsProvides: 0,
            foodProvides: 0,
            terraformBonus: 0,
            production: false,
            effect: {}
          };
          itemsHeaders.forEach((h, idx) => {
            if (h === 'Энергия дает') b.energyProvides = itemsData[j][idx] || 0;
            if (h === 'Энергия потребляет') b.energyCost = itemsData[j][idx] || 0;
            if (h === 'Колонисты дает') b.colonistsProvides = itemsData[j][idx] || 0;
            if (h === 'Еда дает') b.foodProvides = itemsData[j][idx] || 0;
            if (h === 'Бонус терраформинга') b.terraformBonus = itemsData[j][idx] || 0;
            if (h === 'Производство (доход)') b.production = itemsData[j][idx] || false;
            if (h === 'Эффект (JSON)') b.effect = itemsData[j][idx] ? JSON.parse(itemsData[j][idx]) : {};
          });
          buildings.push(b);
          break;
        }
      }
    }
  }
  return buildings;
}

// ================= API GET =================
function doGet(e) {
  try {
    const action = e.parameter.action;
    switch (action) {
      case 'getTeams':
        return getTeams();
      case 'getTeamByCode':
        return getTeamByCode(e.parameter.code);
      case 'getTransactions':
        return getTransactions(e.parameter.teamId);
      case 'getRating':
        return getRating();
      case 'getShopItems':
        return getShopItems();
      case 'getTeamInventory':
        return getTeamInventory(e.parameter.teamId);
      case 'getContracts':
        return getContracts();
      case 'getEvents':
        return getEvents();
      case 'getGameState':
        return getGameState();
      case 'getFinalScores':
        return getFinalScores();
      default:
        return createResponse({ error: 'Неизвестное действие' }, 400);
    }
  } catch (error) {
    return createResponse({ error: error.message }, 500);
  }
}

function getGameState() {
  const ss = getSpreadsheet();
  const sheet = ss.getSheetByName('game_state');
  if (!sheet) return createResponse({ epoch: 0, name: 'Заря' });
  const data = sheet.getDataRange().getValues();
  let epoch = 0, name = 'Заря';
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] === 'current_epoch') epoch = parseInt(data[i][1]) || 0;
    if (data[i][0] === 'epoch_name') name = data[i][1] || 'Заря';
  }
  return createResponse({ epoch, name });
}

function getTeams() {
  const ss = getSpreadsheet();
  const teamsSheet = ss.getSheetByName('teams');
  const teamsData = teamsSheet.getDataRange().getValues();
  const headers = teamsSheet.getRange(1, 1, 1, teamsSheet.getLastColumn()).getValues()[0];

  const purchasesSheet = ss.getSheetByName('purchases');
  const purchasesData = purchasesSheet ? purchasesSheet.getDataRange().getValues() : [];
  const teamStats = {};

  for (let i = 1; i < purchasesData.length; i++) {
    const teamId = purchasesData[i][1];
    const price = purchasesData[i][4] || 0;
    if (!teamStats[teamId]) teamStats[teamId] = { count: 0, totalSpent: 0 };
    teamStats[teamId].count++;
    teamStats[teamId].totalSpent += price;
  }

  const teams = [];
  for (let i = 1; i < teamsData.length; i++) {
    const team = {
      id: teamsData[i][0],
      name: teamsData[i][1],
      score: teamsData[i][2] || 0,
      code: teamsData[i][3],
      contact: teamsData[i][4]
    };
    headers.forEach((h, idx) => {
      if (h === 'Энергослоты') team.energySlots = teamsData[i][idx] || 0;
      if (h === 'Колонисты') team.colonists = teamsData[i][idx] || 0;
      if (h === 'Запас еды') team.foodSupply = teamsData[i][idx] || 0;
      if (h === 'Индекс терраформинга') team.terraformIndex = teamsData[i][idx] || 50;
      if (h === 'Взнос тотема (номинал)') team.totemInvested = teamsData[i][idx] || 0;
      if (h === 'Всего взносов тотема') team.totemTotalInvested = teamsData[i][idx] || 0;
      if (h === 'Текущее событие') team.currentEvent = teamsData[i][idx] || null;
      if (h === 'Длительность события') team.eventDuration = teamsData[i][idx] || 0;
      if (h === 'Коэффициент красоты') team.beautyFactor = parseFloat(teamsData[i][idx]) || 1.0;
      if (h === 'Эпоха последнего взноса в тотем') team.lastTotemEpoch = parseInt(teamsData[i][idx]) || 0;
    });
    team.purchasedCount = teamStats[team.id] ? teamStats[team.id].count : 0;
    team.totalSpent = teamStats[team.id] ? teamStats[team.id].totalSpent : 0;
    teams.push(team);
  }
  return createResponse({ teams });
}

function getTeamByCode(code) {
  const teamsRes = getTeams();
  const teams = JSON.parse(teamsRes.getContent()).data.teams;
  const team = teams.find(t => t.code && t.code.toString().toUpperCase() === code.toString().toUpperCase().trim());
  if (team) return createResponse({ team });
  return createResponse({ error: 'Команда не найдена' }, 404);
}

function getRating() {
  const teamsRes = getTeams();
  const teams = JSON.parse(teamsRes.getContent()).data.teams;
  const sorted = teams.sort((a, b) => (b.score || 0) - (a.score || 0));
  return createResponse({ rating: sorted });
}

function getTransactions(teamId) {
  const ss = getSpreadsheet();
  const sheet = ss.getSheetByName('transactions');
  const data = sheet.getDataRange().getValues();
  const transactions = [];
  for (let i = 1; i < data.length; i++) {
    if (!teamId || data[i][1] == teamId) {
      transactions.push({
        timestamp: data[i][0],
        teamId: data[i][1],
        points: data[i][2],
        reason: data[i][3],
        moderator: data[i][4]
      });
    }
  }
  transactions.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
  return createResponse({ transactions });
}

function getShopItems() {
  const ss = getSpreadsheet();
  const sheet = ss.getSheetByName('items');
  if (!sheet) return createResponse({ items: [] });
  const data = sheet.getDataRange().getValues();
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const items = [];
  for (let i = 1; i < data.length; i++) {
    const item = {
      id: data[i][0],
      name: data[i][1],
      description: data[i][2],
      price: data[i][3],
      icon: data[i][4],
      type: data[i][5]
    };
    headers.forEach((h, idx) => {
      if (h === 'Энергия дает') item.energyProvides = data[i][idx] || 0;
      if (h === 'Энергия потребляет') item.energyCost = data[i][idx] || 0;
      if (h === 'Колонисты дает') item.colonistsProvides = data[i][idx] || 0;
      if (h === 'Еда дает') item.foodProvides = data[i][idx] || 0;
      if (h === 'Бонус терраформинга') item.terraformBonus = data[i][idx] || 0;
      if (h === 'Производство (доход)') item.production = data[i][idx] || false;
      if (h === 'Уникальное') item.unique = data[i][idx] || false;
      if (h === 'Макс на команду') item.maxPerTeam = data[i][idx] || 0;
      if (h === 'Эффект (JSON)') item.effect = data[i][idx] ? JSON.parse(data[i][idx]) : {};
    });
    items.push(item);
  }
  return createResponse({ items });
}

function getTeamInventory(teamId) {
  const ss = getSpreadsheet();
  const purchasesSheet = ss.getSheetByName('purchases');
  if (!purchasesSheet) return createResponse({ items: [] });

  const purchasesData = purchasesSheet.getDataRange().getValues();
  const statusCol = purchasesSheet.getLastColumn();
  const purchaseList = [];
  for (let i = 1; i < purchasesData.length; i++) {
    if (purchasesData[i][1] == teamId) {
      purchaseList.push({
        purchaseId: purchasesData[i][0],
        itemId: purchasesData[i][2],
        date: purchasesData[i][3],
        price: purchasesData[i][4],
        status: purchasesData[i][statusCol - 1] || 'куплено'
      });
    }
  }

  if (purchaseList.length === 0) return createResponse({ items: [] });

  const itemsSheet = ss.getSheetByName('items');
  const itemsData = itemsSheet.getDataRange().getValues();
  const itemsHeaders = itemsSheet.getRange(1, 1, 1, itemsSheet.getLastColumn()).getValues()[0];
  const items = [];
  for (let i = 1; i < itemsData.length; i++) {
    const itemId = itemsData[i][0];
    const purchase = purchaseList.find(p => p.itemId == itemId);
    if (purchase) {
      const item = {
        id: itemId,
        name: itemsData[i][1],
        description: itemsData[i][2],
        price: itemsData[i][3],
        icon: itemsData[i][4],
        type: itemsData[i][5]
      };
      itemsHeaders.forEach((h, idx) => {
        if (h === 'Энергия дает') item.energyProvides = itemsData[i][idx] || 0;
        if (h === 'Энергия потребляет') item.energyCost = itemsData[i][idx] || 0;
        if (h === 'Колонисты дает') item.colonistsProvides = itemsData[i][idx] || 0;
        if (h === 'Еда дает') item.foodProvides = itemsData[i][idx] || 0;
        if (h === 'Бонус терраформинга') item.terraformBonus = itemsData[i][idx] || 0;
        if (h === 'Производство (доход)') item.production = itemsData[i][idx] || false;
        if (h === 'Уникальное') item.unique = itemsData[i][idx] || false;
        if (h === 'Макс на команду') item.maxPerTeam = itemsData[i][idx] || 0;
        if (h === 'Эффект (JSON)') item.effect = itemsData[i][idx] ? JSON.parse(itemsData[i][idx]) : {};
      });
      item.purchaseId = purchase.purchaseId;
      item.status = purchase.status;
      items.push(item);
    }
  }
  return createResponse({ items });
}

function getContracts() {
  const ss = getSpreadsheet();
  const sheet = ss.getSheetByName('contracts');
  if (!sheet) return createResponse({ contracts: [] });
  const data = sheet.getDataRange().getValues();
  const contracts = [];
  for (let i = 1; i < data.length; i++) {
    contracts.push({
      id: data[i][0],
      desc: data[i][1],
      condition: data[i][2] ? JSON.parse(data[i][2]) : {},
      reward: data[i][3],
      active: data[i][4] === true
    });
  }
  return createResponse({ contracts });
}

function getEvents() {
  const ss = getSpreadsheet();
  const sheet = ss.getSheetByName('events');
  if (!sheet) return createResponse({ events: [] });
  const data = sheet.getDataRange().getValues();
  const events = [];
  for (let i = 1; i < data.length; i++) {
    events.push({
      id: data[i][0],
      name: data[i][1],
      type: data[i][2],
      description: data[i][3],
      effect: data[i][4] ? JSON.parse(data[i][4]) : {}
    });
  }
  return createResponse({ events });
}

function getFinalScores() {
  const teamsRes = getTeams();
  const teams = JSON.parse(teamsRes.getContent()).data.teams;
  const final = teams.map(t => {
    const terraformK = 0.5 + (t.terraformIndex || 50) / 100;
    const finalScore = Math.round((t.score || 0) * (t.beautyFactor || 1.0) * terraformK);
    return {
      id: t.id,
      name: t.name,
      score: t.score,
      terraformIndex: t.terraformIndex,
      beautyFactor: t.beautyFactor,
      finalScore: finalScore
    };
  }).sort((a, b) => b.finalScore - a.finalScore);
  return createResponse({ final });
}

// ================= API POST =================
function doPost(e) {
  try {
    let data;
    try {
      data = JSON.parse(e.postData.contents);
    } catch (parseError) {
      data = e.parameter;
    }

    const action = data.action;

    const adminActions = [
      'addPoints', 'addTeam', 'updateTeam', 'deleteTeam',
      'addItem', 'updateItem', 'deleteItem',
      'updatePurchaseStatus', 'processRoundIncome', 'applyEvent',
      'assignContract', 'investInFund', 'takeLoan', 'repayLoan',
      'activateVenture', 'activateRecreation', 'checkContract',
      'spinWheel', 'finalTotem',
      'addEvent', 'updateEvent', 'deleteEvent',
      'advanceEpoch', 'setBeautyFactor'
    ];

    if (adminActions.includes(action)) {
      if (!data.password || data.password !== CONFIG.ADMIN_PASSWORD) {
        return createResponse({ error: 'Неверный пароль организатора' }, 403);
      }
    }

    switch (action) {
      case 'checkPassword':
        return createResponse({ valid: data.password === CONFIG.ADMIN_PASSWORD });
      case 'addPoints':
        return addPoints(data);
      case 'addTeam':
        return addTeam(data);
      case 'updateTeam':
        return updateTeam(data);
      case 'deleteTeam':
        return deleteTeam(data);
      case 'addItem':
        return addItem(data);
      case 'updateItem':
        return updateItem(data);
      case 'deleteItem':
        return deleteItem(data);
      case 'buyItem':
        return buyItem(data);
      case 'updatePurchaseStatus':
        return updatePurchaseStatus(data);
      case 'processRoundIncome':
        return processRoundIncome(data);
      case 'applyEvent':
        return applyEvent(data);
      case 'spinWheel':
        return spinWheel(data);
      case 'totemContribute':
        return totemContribute(data);
      case 'finalTotem':
        return finalTotem(data);
      case 'investInFund':
        return investInFund(data);
      case 'takeLoan':
        return takeLoan(data);
      case 'repayLoan':
        return repayLoan(data);
      case 'activateVenture':
        return activateVenture(data);
      case 'activateRecreation':
        return activateRecreation(data);
      case 'checkContract':
        return checkContract(data);
      case 'assignContract':
        return assignContractToTeam(data);
      case 'addEvent':
        return addEvent(data);
      case 'updateEvent':
        return updateEvent(data);
      case 'deleteEvent':
        return deleteEvent(data);
      case 'advanceEpoch':
        return advanceEpoch(data);
      case 'setBeautyFactor':
        return setBeautyFactor(data);
      default:
        return createResponse({ error: 'Неизвестное действие' }, 400);
    }
  } catch (error) {
    return createResponse({ error: error.message }, 500);
  }
}

// ================= ОСНОВНЫЕ ФУНКЦИИ =================
function addPoints(data) {
  const teamId = parseInt(data.teamId);
  const points = parseInt(data.points);
  const reason = data.reason || '';
  const moderator = data.moderator || 'Организатор';
  const ss = getSpreadsheet();
  const newScore = updateTeamScore(ss, teamId, points, reason, moderator);
  if (newScore === null) return createResponse({ error: 'Команда не найдена' }, 404);
  return createResponse({ success: true, newScore });
}

function addTeam(data) {
  const name = data.name;
  const code = data.code.toUpperCase();
  const contact = data.contact || '';
  const ss = getSpreadsheet();
  const sheet = ss.getSheetByName('teams');
  const teamsData = sheet.getDataRange().getValues();
  for (let i = 1; i < teamsData.length; i++) {
    if (teamsData[i][3] && teamsData[i][3].toString().toUpperCase() === code) {
      return createResponse({ error: 'Код уже используется' }, 400);
    }
  }
  let maxId = 0;
  for (let i = 1; i < teamsData.length; i++) maxId = Math.max(maxId, parseInt(teamsData[i][0]) || 0);
  const newId = maxId + 1;
  sheet.appendRow([newId, name, 0, code, contact, 0, 0, '', null, false, 0, 0, 0, 50, 0, 0, null, 0, 1.0, 0]);
  return createResponse({ success: true, team: { id: newId, name, score: 0, code, contact } });
}

function updateTeam(data) {
  const teamId = parseInt(data.teamId);
  const name = data.name;
  const code = data.code.toUpperCase();
  const contact = data.contact || '';
  const ss = getSpreadsheet();
  const sheet = ss.getSheetByName('teams');
  const teamsData = sheet.getDataRange().getValues();
  let rowIndex = -1;
  for (let i = 1; i < teamsData.length; i++) {
    if (teamsData[i][0] == teamId) {
      rowIndex = i + 1;
      break;
    }
  }
  if (rowIndex === -1) return createResponse({ error: 'Команда не найдена' }, 404);
  const oldCode = teamsData[rowIndex - 1][3];
  if (code !== oldCode) {
    for (let i = 1; i < teamsData.length; i++) {
      if (i !== rowIndex - 1 && teamsData[i][3] && teamsData[i][3].toString().toUpperCase() === code) {
        return createResponse({ error: 'Код уже используется' }, 400);
      }
    }
  }
  sheet.getRange(rowIndex, 2).setValue(name);
  sheet.getRange(rowIndex, 4).setValue(code);
  sheet.getRange(rowIndex, 5).setValue(contact);
  return createResponse({ success: true });
}

function deleteTeam(data) {
  const teamId = parseInt(data.teamId);
  const ss = getSpreadsheet();
  const sheet = ss.getSheetByName('teams');
  const teamsData = sheet.getDataRange().getValues();
  let rowIndex = -1;
  for (let i = 1; i < teamsData.length; i++) {
    if (teamsData[i][0] == teamId) {
      rowIndex = i + 1;
      break;
    }
  }
  if (rowIndex === -1) return createResponse({ error: 'Команда не найдена' }, 404);
  sheet.deleteRow(rowIndex);
  const transSheet = ss.getSheetByName('transactions');
  const transData = transSheet.getDataRange().getValues();
  for (let i = transData.length - 1; i >= 1; i--) {
    if (transData[i][1] == teamId) transSheet.deleteRow(i + 1);
  }
  const purchasesSheet = ss.getSheetByName('purchases');
  const purchasesData = purchasesSheet.getDataRange().getValues();
  for (let i = purchasesData.length - 1; i >= 1; i--) {
    if (purchasesData[i][1] == teamId) purchasesSheet.deleteRow(i + 1);
  }
  return createResponse({ success: true });
}

function addItem(data) {
  const name = data.name;
  const description = data.description || '';
  const price = parseInt(data.price) || 0;
  const icon = data.icon || 'fa-solid fa-question';
  const type = data.type || 'общее';
  const energyProvides = parseInt(data.energyProvides) || 0;
  const energyCost = parseInt(data.energyCost) || 0;
  const colonistsProvides = parseInt(data.colonistsProvides) || 0;
  const foodProvides = parseInt(data.foodProvides) || 0;
  const terraformBonus = parseInt(data.terraformBonus) || 0;
  const production = data.production === 'true' || data.production === true;
  const unique = data.unique === 'true' || data.unique === true;
  const maxPerTeam = parseInt(data.maxPerTeam) || 0;
  const effect = data.effect || '{}';
  const ss = getSpreadsheet();
  const sheet = ss.getSheetByName('items');
  const itemsData = sheet.getDataRange().getValues();
  let maxId = 0;
  for (let i = 1; i < itemsData.length; i++) maxId = Math.max(maxId, parseInt(itemsData[i][0]) || 0);
  const newId = maxId + 1;
  sheet.appendRow([newId, name, description, price, icon, type,
    energyProvides, energyCost, colonistsProvides, foodProvides,
    terraformBonus, production, unique, maxPerTeam, effect
  ]);
  return createResponse({ success: true, item: { id: newId, name, price } });
}

function updateItem(data) {
  const itemId = parseInt(data.itemId);
  const name = data.name;
  const description = data.description || '';
  const price = parseInt(data.price) || 0;
  const icon = data.icon || 'fa-solid fa-question';
  const type = data.type || 'общее';
  const energyProvides = parseInt(data.energyProvides) || 0;
  const energyCost = parseInt(data.energyCost) || 0;
  const colonistsProvides = parseInt(data.colonistsProvides) || 0;
  const foodProvides = parseInt(data.foodProvides) || 0;
  const terraformBonus = parseInt(data.terraformBonus) || 0;
  const production = data.production === 'true' || data.production === true;
  const unique = data.unique === 'true' || data.unique === true;
  const maxPerTeam = parseInt(data.maxPerTeam) || 0;
  const effect = data.effect || '{}';
  const ss = getSpreadsheet();
  const sheet = ss.getSheetByName('items');
  const itemsData = sheet.getDataRange().getValues();
  let rowIndex = -1;
  for (let i = 1; i < itemsData.length; i++) {
    if (itemsData[i][0] == itemId) {
      rowIndex = i + 1;
      break;
    }
  }
  if (rowIndex === -1) return createResponse({ error: 'Товар не найден' }, 404);
  sheet.getRange(rowIndex, 2).setValue(name);
  sheet.getRange(rowIndex, 3).setValue(description);
  sheet.getRange(rowIndex, 4).setValue(price);
  sheet.getRange(rowIndex, 5).setValue(icon);
  sheet.getRange(rowIndex, 6).setValue(type);
  sheet.getRange(rowIndex, 7).setValue(energyProvides);
  sheet.getRange(rowIndex, 8).setValue(energyCost);
  sheet.getRange(rowIndex, 9).setValue(colonistsProvides);
  sheet.getRange(rowIndex, 10).setValue(foodProvides);
  sheet.getRange(rowIndex, 11).setValue(terraformBonus);
  sheet.getRange(rowIndex, 12).setValue(production);
  sheet.getRange(rowIndex, 13).setValue(unique);
  sheet.getRange(rowIndex, 14).setValue(maxPerTeam);
  sheet.getRange(rowIndex, 15).setValue(effect);
  return createResponse({ success: true });
}

function deleteItem(data) {
  const itemId = parseInt(data.itemId);
  const ss = getSpreadsheet();
  const sheet = ss.getSheetByName('items');
  const itemsData = sheet.getDataRange().getValues();
  let rowIndex = -1;
  for (let i = 1; i < itemsData.length; i++) {
    if (itemsData[i][0] == itemId) {
      rowIndex = i + 1;
      break;
    }
  }
  if (rowIndex === -1) return createResponse({ error: 'Товар не найден' }, 404);
  sheet.deleteRow(rowIndex);
  const purchasesSheet = ss.getSheetByName('purchases');
  const purchasesData = purchasesSheet.getDataRange().getValues();
  for (let i = purchasesData.length - 1; i >= 1; i--) {
    if (purchasesData[i][2] == itemId) purchasesSheet.deleteRow(i + 1);
  }
  return createResponse({ success: true });
}

function buyItem(data) {
  const teamId = parseInt(data.teamId);
  const itemId = parseInt(data.itemId);
  const ss = getSpreadsheet();

  const itemsSheet = ss.getSheetByName('items');
  const itemsData = itemsSheet.getDataRange().getValues();
  const itemsHeaders = itemsSheet.getRange(1, 1, 1, itemsSheet.getLastColumn()).getValues()[0];
  let item = null;
  for (let i = 1; i < itemsData.length; i++) {
    if (itemsData[i][0] == itemId) {
      item = { id: itemId, name: itemsData[i][1], price: itemsData[i][3] };
      itemsHeaders.forEach((h, idx) => {
        if (h === 'Энергия дает') item.energyProvides = itemsData[i][idx] || 0;
        if (h === 'Энергия потребляет') item.energyCost = itemsData[i][idx] || 0;
        if (h === 'Уникальное') item.unique = itemsData[i][idx] || false;
        if (h === 'Макс на команду') item.maxPerTeam = itemsData[i][idx] || 0;
      });
      break;
    }
  }
  if (!item) return createResponse({ error: 'Товар не найден' }, 404);

  // Проверка уникальности
  if (item.unique) {
    const purchasesSheet = ss.getSheetByName('purchases');
    const purchasesData = purchasesSheet.getDataRange().getValues();
    for (let i = 1; i < purchasesData.length; i++) {
      if (purchasesData[i][2] == itemId) {
        return createResponse({ error: 'Это уникальное здание уже куплено другой командой' }, 400);
      }
    }
  }

  // Проверка макс на команду
  if (item.maxPerTeam > 0) {
    const purchasesSheet = ss.getSheetByName('purchases');
    const purchasesData = purchasesSheet.getDataRange().getValues();
    let count = 0;
    for (let i = 1; i < purchasesData.length; i++) {
      if (purchasesData[i][1] == teamId && purchasesData[i][2] == itemId) count++;
    }
    if (count >= item.maxPerTeam) {
      return createResponse({ error: `Можно построить не более ${item.maxPerTeam} таких зданий` }, 400);
    }
  }

  // Проверка наличия здания со статусом "куплено" (ожидание выдачи)
  const purchasesSheet = ss.getSheetByName('purchases');
  const purchasesData = purchasesSheet.getDataRange().getValues();
  const statusCol = purchasesSheet.getLastColumn();
  for (let i = 1; i < purchasesData.length; i++) {
    if (purchasesData[i][1] == teamId && purchasesData[i][statusCol - 1] === 'куплено') {
      return createResponse({ error: 'Сначала завершите выдачу предыдущего макета' }, 400);
    }
  }

  // Проверка энергии (слотов)
  const teamsSheet = ss.getSheetByName('teams');
  const teamsData = teamsSheet.getDataRange().getValues();
  let teamRow = -1,
    teamScore = 0,
    energySlots = 0;
  for (let i = 1; i < teamsData.length; i++) {
    if (teamsData[i][0] == teamId) {
      teamRow = i + 1;
      teamScore = parseFloat(teamsData[i][2]) || 0;
      energySlots = parseFloat(teamsData[i][10]) || 0;
      break;
    }
  }
  if (teamRow === -1) return createResponse({ error: 'Команда не найдена' }, 404);

  const buildings = getFunctionalBuildings(teamId, ss);
  let totalEnergyCost = 0;
  buildings.forEach(b => totalEnergyCost += b.energyCost);
  if (item.energyCost && (totalEnergyCost + item.energyCost > energySlots)) {
    return createResponse({ error: 'Недостаточно энергии (слотов)' }, 400);
  }

  if (teamScore < item.price) return createResponse({ error: 'Недостаточно импульсов' }, 400);

  const newScore = teamScore - item.price;
  teamsSheet.getRange(teamRow, 3).setValue(newScore);

  let maxPurchaseId = 0;
  for (let i = 1; i < purchasesData.length; i++) {
    maxPurchaseId = Math.max(maxPurchaseId, parseInt(purchasesData[i][0]) || 0);
  }
  const newPurchaseId = maxPurchaseId + 1;
  purchasesSheet.appendRow([newPurchaseId, teamId, itemId, new Date(), item.price, 'куплено']);

  logTransaction(ss, teamId, -item.price, `Покупка: ${item.name}`, 'Команда');

  return createResponse({
    success: true,
    newScore,
    purchaseId: newPurchaseId,
    item: { id: itemId, name: item.name, price: item.price }
  });
}

function updatePurchaseStatus(data) {
  const purchaseId = parseInt(data.purchaseId);
  const newStatus = data.status;
  const ss = getSpreadsheet();
  const sheet = ss.getSheetByName('purchases');
  const purchasesData = sheet.getDataRange().getValues();
  let rowIndex = -1,
    teamId = null,
    itemId = null;
  for (let i = 1; i < purchasesData.length; i++) {
    if (purchasesData[i][0] == purchaseId) {
      rowIndex = i + 1;
      teamId = purchasesData[i][1];
      itemId = purchasesData[i][2];
      break;
    }
  }
  if (rowIndex === -1) return createResponse({ error: 'Покупка не найдена' }, 404);
  const statusCol = sheet.getLastColumn();
  sheet.getRange(rowIndex, statusCol).setValue(newStatus);

  if (newStatus === 'функционирует' && teamId) {
    updateTeamResources(teamId, ss);
  }

  return createResponse({ success: true, newStatus });
}

function updateTeamResources(teamId, ss) {
  const buildings = getFunctionalBuildings(teamId, ss);
  const teamsSheet = ss.getSheetByName('teams');
  const teamsData = teamsSheet.getDataRange().getValues();
  let teamRow = -1;
  for (let i = 1; i < teamsData.length; i++) {
    if (teamsData[i][0] == teamId) {
      teamRow = i + 1;
      break;
    }
  }
  if (teamRow === -1) return;

  let energySlots = 0,
    colonists = 0,
    foodSupply = 0;
  buildings.forEach(b => {
    energySlots += b.energyProvides;
    colonists += b.colonistsProvides;
    foodSupply += b.foodProvides;
  });

  teamsSheet.getRange(teamRow, 11).setValue(energySlots);
  teamsSheet.getRange(teamRow, 12).setValue(colonists);
  teamsSheet.getRange(teamRow, 13).setValue(foodSupply);
}

function processRoundIncome(data) {
  const ss = getSpreadsheet();
  const teamsSheet = ss.getSheetByName('teams');
  const teamsData = teamsSheet.getDataRange().getValues();

  // Загружаем все события для быстрого доступа по имени
  const eventsSheet = ss.getSheetByName('events');
  const eventsData = eventsSheet ? eventsSheet.getDataRange().getValues() : [];
  const eventsMap = {};
  for (let j = 1; j < eventsData.length; j++) {
    const name = eventsData[j][1];
    const effectStr = eventsData[j][4];
    if (name && effectStr) {
      try { eventsMap[name] = JSON.parse(effectStr); } catch (e) {}
    }
  }

  for (let i = 1; i < teamsData.length; i++) {
    const teamId = teamsData[i][0];
    const buildings = getFunctionalBuildings(teamId, ss);
    if (buildings.length === 0) continue;

    const boosters = {};
    buildings.forEach(b => {
      if (b.effect.boostType) {
        if (!boosters[b.effect.boostType]) boosters[b.effect.boostType] = 0;
        boosters[b.effect.boostType] += b.effect.value || 0;
      }
    });

    const colonists = buildings.reduce((sum, b) => sum + (b.colonistsProvides || 0), 0);
    let requiredStaff = 0;
    buildings.forEach(b => {
      if (b.type === 'добыча' || b.type === 'производство' || b.type === 'бустер' || b.type === 'энергия' || b.type === 'еда') {
        requiredStaff += b.energyCost;
      }
    });
    const r = colonists === 0 ? 1 : Math.min(1, colonists / requiredStaff);

    const foodProduced = buildings.reduce((sum, b) => sum + (b.foodProvides || 0), 0);
    let c = colonists === 0 ? 1 : foodProduced / colonists;
    let f;
    if (c >= 1) f = 1;
    else if (c >= 0.8) f = 0.95;
    else if (c >= 0.6) f = 0.85;
    else f = 0.75;

    let totalIncome = 0;
    buildings.forEach(b => {
      if (b.effect.income) {
        let base = b.effect.income;
        let boost = 1;
        if (b.type === 'добыча' && boosters['добыча']) boost += boosters['добыча'];
        if (b.type === 'производство' && boosters['производство']) boost += boosters['производство'];
        if (b.effect.incomeHigh) {
          const terraform = teamsData[i][13] || 50;
          if (terraform >= (b.effect.terraformReq || 0)) base = b.effect.incomeHigh;
        }
        let income = base * boost * r * f;
        income = Math.floor(income);
        totalIncome += income;
      }
    });

    // Применяем эффект события, если оно активно
    const currentEventName = teamsData[i][16];
    if (currentEventName && eventsMap[currentEventName]) {
      const effect = eventsMap[currentEventName];
      switch (effect.type) {
        case 'incomeBoost':
        case 'incomeMalus':
          totalIncome = Math.floor(totalIncome * (1 + (effect.value || 0)));
          break;
        case 'direct':
          totalIncome += effect.value || 0;
          break;
        default:
          break;
      }
    }

    if (totalIncome !== 0) {
      updateTeamScore(ss, teamId, totalIncome, 'Доход за сезон', 'Система');
    }

    // Обновляем терраформинг
    let terraformDelta = 0;
    buildings.forEach(b => {
      if (b.terraformBonus) terraformDelta += b.terraformBonus;
      if (b.production) terraformDelta -= 2;
    });
    let newTerraform = (teamsData[i][13] || 50) + terraformDelta;
    newTerraform = Math.max(0, Math.min(100, newTerraform));
    teamsSheet.getRange(i + 1, 14).setValue(newTerraform);

    // ⬇️ Уменьшаем длительность события и очищаем, если истекло
    const eventDuration = teamsData[i][17];
    if (eventDuration > 0) {
      const newDuration = eventDuration - 1;
      teamsSheet.getRange(i + 1, 18).setValue(newDuration);
      if (newDuration === 0) {
        teamsSheet.getRange(i + 1, 17).setValue(null); // очищаем название события
      }
    }
  }

  return createResponse({ success: true, message: 'Доход начислен' });
}

function spinWheel(data) {
  const season = parseInt(data.season);
  if (season < 3 || season > 6) return createResponse({ error: 'Колесо можно крутить только в сезонах 3-6' }, 400);

  const ss = getSpreadsheet();
  const eventsSheet = ss.getSheetByName('events');
  const eventsData = eventsSheet.getDataRange().getValues();
  if (eventsData.length <= 1) return createResponse({ error: 'Нет событий в таблице' }, 400);

  const positive = [], negative = [];
  for (let i = 1; i < eventsData.length; i++) {
    const type = eventsData[i][2];
    if (type === 'positive') positive.push(eventsData[i]);
    else if (type === 'negative') negative.push(eventsData[i]);
  }

  const isPositive = Math.random() < 0.5;
  const pool = isPositive ? positive : negative;
  if (pool.length === 0) return createResponse({ error: `Нет событий типа ${isPositive ? 'positive' : 'negative'}` }, 400);

  const randomIndex = Math.floor(Math.random() * pool.length);
  const event = pool[randomIndex];
  const eventName = event[1];
  const eventEffect = JSON.parse(event[4] || '{}');

  const teamsSheet = ss.getSheetByName('teams');
  const teamsData = teamsSheet.getDataRange().getValues();
  for (let i = 1; i < teamsData.length; i++) {
    teamsSheet.getRange(i + 1, 17).setValue(eventName);
    teamsSheet.getRange(i + 1, 18).setValue(1);
  }

  return createResponse({ success: true, event: { name: eventName, effect: eventEffect } });
}

function applyEvent(data) {
  return createResponse({ success: true });
}

function totemContribute(data) {
  const teamId = parseInt(data.teamId);
  const amount = parseInt(data.amount);
  if (amount <= 0) return createResponse({ error: 'Сумма должна быть положительной' }, 400);

  const ss = getSpreadsheet();
  const stateSheet = ss.getSheetByName('game_state');
  if (!stateSheet) return createResponse({ error: 'Ошибка: нет данных об эпохе' }, 500);
  const stateData = stateSheet.getDataRange().getValues();
  let currentEpoch = 0;
  for (let i = 1; i < stateData.length; i++) {
    if (stateData[i][0] === 'current_epoch') currentEpoch = parseInt(stateData[i][1]) || 0;
  }

  const teamsSheet = ss.getSheetByName('teams');
  const teamsData = teamsSheet.getDataRange().getValues();
  const headers = teamsSheet.getRange(1, 1, 1, teamsSheet.getLastColumn()).getValues()[0];
  let teamRow = -1,
    score = 0,
    totemInvested = 0,
    totemTotal = 0,
    lastEpoch = 0;

  let lastEpochCol = headers.indexOf('Эпоха последнего взноса в тотем') + 1;
  if (lastEpochCol === 0) {
    lastEpochCol = teamsSheet.getLastColumn() + 1;
    teamsSheet.getRange(1, lastEpochCol).setValue('Эпоха последнего взноса в тотем');
    if (teamsSheet.getLastRow() > 1) {
      teamsSheet.getRange(2, lastEpochCol, teamsSheet.getLastRow() - 1).setValue(0);
    }
  }

  for (let i = 1; i < teamsData.length; i++) {
    if (teamsData[i][0] == teamId) {
      teamRow = i + 1;
      score = parseFloat(teamsData[i][2]) || 0;
      totemInvested = parseFloat(teamsData[i][14]) || 0;
      totemTotal = parseFloat(teamsData[i][15]) || 0;
      lastEpoch = parseInt(teamsData[i][lastEpochCol - 1]) || 0;
      break;
    }
  }
  if (teamRow === -1) return createResponse({ error: 'Команда не найдена' }, 404);

  if (lastEpoch === currentEpoch) {
    return createResponse({ error: 'В этой эпохе вы уже делали взнос в тотем' }, 400);
  }

  if (score < amount) return createResponse({ error: 'Недостаточно импульсов' }, 400);

  const rand = Math.random();
  let deducted;
  if (rand < 0.55) deducted = amount;
  else if (rand < 0.8) deducted = amount * 2;
  else deducted = Math.floor(amount / 2);

  const newScore = score - deducted;
  teamsSheet.getRange(teamRow, 3).setValue(newScore);
  teamsSheet.getRange(teamRow, 15).setValue(totemInvested + amount);
  teamsSheet.getRange(teamRow, 16).setValue(totemTotal + amount);
  teamsSheet.getRange(teamRow, lastEpochCol).setValue(currentEpoch);

  logTransaction(ss, teamId, -deducted, 'Взнос в тотем (фактическое списание)', 'Система');

  return createResponse({ success: true, deducted, newScore, nominalInvested: totemInvested + amount });
}

function finalTotem(data) {
  const ss = getSpreadsheet();
  const teamsSheet = ss.getSheetByName('teams');
  const teamsData = teamsSheet.getDataRange().getValues();
  for (let i = 1; i < teamsData.length; i++) {
    const teamId = teamsData[i][0];
    const totemTotal = parseFloat(teamsData[i][15]) || 0;
    if (totemTotal > 0) {
      const bonus = Math.floor(totemTotal * 1.5);
      updateTeamScore(ss, teamId, bonus, 'Возврат тотема (x1.5)', 'Система');
    }
  }
  return createResponse({ success: true, message: 'Тотем выплачен' });
}

function investInFund(data) {
  const teamId = parseInt(data.teamId);
  const amount = parseInt(data.amount);
  if (amount < 5) return createResponse({ error: 'Минимальная инвестиция 5' }, 400);

  const ss = getSpreadsheet();
  const teamsSheet = ss.getSheetByName('teams');
  const teamsData = teamsSheet.getDataRange().getValues();
  let teamRow = -1,
    currentScore = 0,
    investments = 0;
  for (let i = 1; i < teamsData.length; i++) {
    if (teamsData[i][0] == teamId) {
      teamRow = i + 1;
      currentScore = parseFloat(teamsData[i][2]) || 0;
      investments = parseFloat(teamsData[i][5]) || 0;
      break;
    }
  }
  if (teamRow === -1) return createResponse({ error: 'Команда не найдена' }, 404);
  if (currentScore < amount) return createResponse({ error: 'Недостаточно импульсов' }, 400);

  const newScore = currentScore - amount;
  teamsSheet.getRange(teamRow, 3).setValue(newScore);
  teamsSheet.getRange(teamRow, 6).setValue(investments + amount);
  logTransaction(ss, teamId, -amount, 'Инвестиция в фонд', 'Команда');

  return createResponse({ success: true, newScore, totalInvested: investments + amount });
}

function takeLoan(data) {
  const teamId = parseInt(data.teamId);
  const amount = parseInt(data.amount);
  if (amount < 1 || amount > 10) return createResponse({ error: 'Сумма кредита от 1 до 10' }, 400);

  const ss = getSpreadsheet();
  const teamsSheet = ss.getSheetByName('teams');
  const teamsData = teamsSheet.getDataRange().getValues();
  let teamRow = -1,
    currentScore = 0,
    loan = 0;
  for (let i = 1; i < teamsData.length; i++) {
    if (teamsData[i][0] == teamId) {
      teamRow = i + 1;
      currentScore = parseFloat(teamsData[i][2]) || 0;
      loan = parseFloat(teamsData[i][6]) || 0;
      break;
    }
  }
  if (teamRow === -1) return createResponse({ error: 'Команда не найдена' }, 404);
  if (loan > 0) return createResponse({ error: 'У команды уже есть кредит' }, 400);

  const newScore = currentScore + amount;
  teamsSheet.getRange(teamRow, 3).setValue(newScore);
  teamsSheet.getRange(teamRow, 7).setValue(amount);
  logTransaction(ss, teamId, amount, 'Кредит получен', 'Команда');

  return createResponse({ success: true, newScore, loan: amount });
}

function repayLoan(data) {
  const teamId = parseInt(data.teamId);
  const ss = getSpreadsheet();
  const teamsSheet = ss.getSheetByName('teams');
  const teamsData = teamsSheet.getDataRange().getValues();
  let teamRow = -1,
    currentScore = 0,
    loan = 0;
  for (let i = 1; i < teamsData.length; i++) {
    if (teamsData[i][0] == teamId) {
      teamRow = i + 1;
      currentScore = parseFloat(teamsData[i][2]) || 0;
      loan = parseFloat(teamsData[i][6]) || 0;
      break;
    }
  }
  if (teamRow === -1) return createResponse({ error: 'Команда не найдена' }, 404);
  if (loan === 0) return createResponse({ error: 'Нет кредита' }, 400);

  const repayAmount = Math.ceil(loan * 1.5);
  if (currentScore < repayAmount) return createResponse({ error: 'Недостаточно импульсов для погашения' }, 400);

  const newScore = currentScore - repayAmount;
  teamsSheet.getRange(teamRow, 3).setValue(newScore);
  teamsSheet.getRange(teamRow, 7).setValue(0);
  logTransaction(ss, teamId, -repayAmount, 'Погашение кредита (150%)', 'Система');

  return createResponse({ success: true, newScore });
}

function activateVenture(data) {
  const teamId = parseInt(data.teamId);
  const purchaseId = parseInt(data.purchaseId);
  const ss = getSpreadsheet();

  const purchasesSheet = ss.getSheetByName('purchases');
  const purchasesData = purchasesSheet.getDataRange().getValues();
  let itemId = null;
  for (let i = 1; i < purchasesData.length; i++) {
    if (purchasesData[i][0] == purchaseId && purchasesData[i][1] == teamId) {
      itemId = purchasesData[i][2];
      break;
    }
  }
  if (!itemId) return createResponse({ error: 'Покупка не найдена' }, 404);

  const itemsSheet = ss.getSheetByName('items');
  const itemsData = itemsSheet.getDataRange().getValues();
  let effect = null;
  for (let i = 1; i < itemsData.length; i++) {
    if (itemsData[i][0] == itemId) {
      effect = JSON.parse(itemsData[i][14] || '{}');
      break;
    }
  }
  if (!effect || !effect.gamble) return createResponse({ error: 'Это не венчурный стартап' }, 400);

  const rand = Math.random();
  let gain = 0;
  if (rand < 0.33) gain = 0;
  else if (rand < 0.66) gain = 5;
  else gain = 20;

  if (gain > 0) {
    updateTeamScore(ss, teamId, gain, 'Венчурный стартап: успех', 'Система');
  } else {
    logTransaction(ss, teamId, 0, 'Венчурный стартап: провал', 'Система');
  }

  return createResponse({ success: true, gain });
}

function activateRecreation(data) {
  const teamId = parseInt(data.teamId);
  const purchaseId = parseInt(data.purchaseId);
  const ss = getSpreadsheet();

  const purchasesSheet = ss.getSheetByName('purchases');
  const purchasesData = purchasesSheet.getDataRange().getValues();
  const statusCol = purchasesSheet.getLastColumn();

  const teamBuildings = [];
  for (let i = 1; i < purchasesData.length; i++) {
    if (purchasesData[i][1] == teamId && purchasesData[i][statusCol - 1] === 'функционирует') {
      teamBuildings.push(purchasesData[i][2]);
    }
  }

  const itemsSheet = ss.getSheetByName('items');
  const itemsData = itemsSheet.getDataRange().getValues();
  const itemsHeaders = itemsSheet.getRange(1, 1, 1, itemsSheet.getLastColumn()).getValues()[0];
  const itemsMap = {};
  for (let i = 1; i < itemsData.length; i++) {
    const item = { type: itemsData[i][5] };
    itemsHeaders.forEach((h, idx) => {
      if (h === 'Энергия дает') item.energyProvides = itemsData[i][idx] || 0;
      if (h === 'Энергия потребляет') item.energyCost = itemsData[i][idx] || 0;
      if (h === 'Колонисты дает') item.colonistsProvides = itemsData[i][idx] || 0;
      if (h === 'Еда дает') item.foodProvides = itemsData[i][idx] || 0;
      if (h === 'Бонус терраформинга') item.terraformBonus = itemsData[i][idx] || 0;
      if (h === 'Производство (доход)') item.production = itemsData[i][idx] || false;
      if (h === 'Эффект (JSON)') item.effect = itemsData[i][idx] ? JSON.parse(itemsData[i][idx]) : {};
    });
    itemsMap[itemsData[i][0]] = item;
  }

  let жильёIncome = 0;
  teamBuildings.forEach(itemId => {
    const item = itemsMap[itemId];
    if (item && item.type === 'жильё' && item.effect.income) {
      жильёIncome += item.effect.income;
    }
  });

  if (жильёIncome > 0) {
    updateTeamScore(ss, teamId, жильёIncome, 'Рекреационный комплекс', 'Активация');
  }

  return createResponse({ success: true, bonus: жильёIncome });
}

function checkContract(data) {
  const teamId = parseInt(data.teamId);
  const ss = getSpreadsheet();
  const teamsSheet = ss.getSheetByName('teams');
  const teamsData = teamsSheet.getDataRange().getValues();

  let teamRow = -1,
    contractId = null,
    completed = false;
  for (let i = 1; i < teamsData.length; i++) {
    if (teamsData[i][0] == teamId) {
      teamRow = i + 1;
      contractId = teamsData[i][8];
      completed = teamsData[i][9];
      break;
    }
  }
  if (teamRow === -1) return createResponse({ error: 'Команда не найдена' }, 404);
  if (!contractId || completed) return createResponse({ error: 'Нет активного контракта или уже выполнен' }, 400);

  const contractsSheet = ss.getSheetByName('contracts');
  const contractsData = contractsSheet.getDataRange().getValues();
  let contract = null;
  for (let i = 1; i < contractsData.length; i++) {
    if (contractsData[i][0] == contractId) {
      contract = {
        condition: JSON.parse(contractsData[i][2] || '{}'),
        reward: contractsData[i][3]
      };
      break;
    }
  }
  if (!contract) return createResponse({ error: 'Контракт не найден' }, 404);

  const buildings = getFunctionalBuildings(teamId, ss);
  const typeCounts = {};
  const uniqueTypes = new Set();
  buildings.forEach(b => {
    if (b.type) {
      typeCounts[b.type] = (typeCounts[b.type] || 0) + 1;
      uniqueTypes.add(b.type);
    }
  });

  let conditionMet = false;
  const cond = contract.condition;
  if (cond.minCount) {
    conditionMet = true;
    for (let type in cond.minCount) {
      if ((typeCounts[type] || 0) < cond.minCount[type]) {
        conditionMet = false;
        break;
      }
    }
  } else if (cond.noLoan) {
    const loan = teamsData[teamRow - 1][6] || 0;
    conditionMet = (loan === 0);
  } else if (cond.minUniqueTypes) {
    conditionMet = (uniqueTypes.size >= cond.minUniqueTypes);
  }

  if (conditionMet) {
    updateTeamScore(ss, teamId, contract.reward, 'Выполнение контракта', 'Система');
    teamsSheet.getRange(teamRow, 10).setValue(true);
    return createResponse({ success: true, reward: contract.reward });
  } else {
    return createResponse({ success: false, message: 'Условие не выполнено' });
  }
}

function assignContractToTeam(data) {
  const teamId = parseInt(data.teamId);
  const ss = getSpreadsheet();

  const contractsSheet = ss.getSheetByName('contracts');
  const contractsData = contractsSheet.getDataRange().getValues();
  const activeContracts = [];
  for (let i = 1; i < contractsData.length; i++) {
    if (contractsData[i][4] === true) {
      activeContracts.push({
        id: contractsData[i][0],
        condition: JSON.parse(contractsData[i][2] || '{}'),
        reward: contractsData[i][3]
      });
    }
  }
  if (activeContracts.length === 0) return createResponse({ error: 'Нет активных контрактов' }, 400);

  const randomIndex = Math.floor(Math.random() * activeContracts.length);
  const contract = activeContracts[randomIndex];

  const teamsSheet = ss.getSheetByName('teams');
  const teamsData = teamsSheet.getDataRange().getValues();
  let teamRow = -1;
  for (let i = 1; i < teamsData.length; i++) {
    if (teamsData[i][0] == teamId) {
      teamRow = i + 1;
      break;
    }
  }
  if (teamRow === -1) return createResponse({ error: 'Команда не найдена' }, 404);

  teamsSheet.getRange(teamRow, 9).setValue(contract.id);
  teamsSheet.getRange(teamRow, 10).setValue(false);

  return createResponse({ success: true, contract: { id: contract.id, reward: contract.reward } });
}

// ================= УПРАВЛЕНИЕ СОБЫТИЯМИ =================
function addEvent(data) {
  const name = data.name;
  const type = data.type;
  const description = data.description || '';
  const effect = data.effect || '{}';
  const ss = getSpreadsheet();
  const sheet = ss.getSheetByName('events');
  const eventsData = sheet.getDataRange().getValues();
  let maxId = 0;
  for (let i = 1; i < eventsData.length; i++) maxId = Math.max(maxId, parseInt(eventsData[i][0]) || 0);
  const newId = maxId + 1;
  sheet.appendRow([newId, name, type, description, effect]);
  return createResponse({ success: true, event: { id: newId, name, type, description, effect: JSON.parse(effect) } });
}

function updateEvent(data) {
  const eventId = parseInt(data.eventId);
  const name = data.name;
  const type = data.type;
  const description = data.description || '';
  const effect = data.effect || '{}';
  const ss = getSpreadsheet();
  const sheet = ss.getSheetByName('events');
  const eventsData = sheet.getDataRange().getValues();
  let rowIndex = -1;
  for (let i = 1; i < eventsData.length; i++) {
    if (eventsData[i][0] == eventId) {
      rowIndex = i + 1;
      break;
    }
  }
  if (rowIndex === -1) return createResponse({ error: 'Событие не найдено' }, 404);
  sheet.getRange(rowIndex, 2).setValue(name);
  sheet.getRange(rowIndex, 3).setValue(type);
  sheet.getRange(rowIndex, 4).setValue(description);
  sheet.getRange(rowIndex, 5).setValue(effect);
  return createResponse({ success: true });
}

function deleteEvent(data) {
  const eventId = parseInt(data.eventId);
  const ss = getSpreadsheet();
  const sheet = ss.getSheetByName('events');
  const eventsData = sheet.getDataRange().getValues();
  let rowIndex = -1;
  for (let i = 1; i < eventsData.length; i++) {
    if (eventsData[i][0] == eventId) {
      rowIndex = i + 1;
      break;
    }
  }
  if (rowIndex === -1) return createResponse({ error: 'Событие не найдено' }, 404);
  sheet.deleteRow(rowIndex);
  return createResponse({ success: true });
}

// ================= УПРАВЛЕНИЕ ЭПОХАМИ =================
function advanceEpoch(data) {
  const ss = getSpreadsheet();
  
  // Начисляем доход за текущий сезон (один раз)
  processRoundIncome(data);

  const sheet = ss.getSheetByName('game_state');
  if (!sheet) return createResponse({ error: 'Лист game_state не найден' }, 404);
  
  const stateData = sheet.getDataRange().getValues();
  let epochRow = -1, nameRow = -1;
  for (let i = 1; i < stateData.length; i++) {
    if (stateData[i][0] === 'current_epoch') epochRow = i + 1;
    if (stateData[i][0] === 'epoch_name') nameRow = i + 1;
  }
  if (epochRow === -1 || nameRow === -1) return createResponse({ error: 'Параметры эпохи не найдены' }, 404);

  const currentEpoch = parseInt(stateData[epochRow - 1][1]) || 0;
  const newEpoch = currentEpoch + 1;
  sheet.getRange(epochRow, 2).setValue(newEpoch);

  const epochNames = ['Заря', 'Рассвет', 'День', 'Сумерки', 'Ночь', 'Зенит', 'Финал'];
  if (newEpoch <= epochNames.length) {
    sheet.getRange(nameRow, 2).setValue(epochNames[newEpoch - 1]);
  } else {
    sheet.getRange(nameRow, 2).setValue(`Эпоха ${newEpoch}`);
  }

  return createResponse({ success: true, newEpoch });
}

// ================= КОЭФФИЦИЕНТ КРАСОТЫ =================
function setBeautyFactor(data) {
  const teamId = parseInt(data.teamId);
  const value = parseFloat(data.value);
  if (value < 0.5 || value > 1.5) return createResponse({ error: 'Коэффициент должен быть от 0.5 до 1.5' }, 400);
  const ss = getSpreadsheet();
  const teamsSheet = ss.getSheetByName('teams');
  const teamsData = teamsSheet.getDataRange().getValues();
  const headers = teamsSheet.getRange(1, 1, 1, teamsSheet.getLastColumn()).getValues()[0];
  let beautyCol = headers.indexOf('Коэффициент красоты') + 1;
  if (beautyCol === 0) {
    beautyCol = teamsSheet.getLastColumn() + 1;
    teamsSheet.getRange(1, beautyCol).setValue('Коэффициент красоты');
    if (teamsSheet.getLastRow() > 1) {
      teamsSheet.getRange(2, beautyCol, teamsSheet.getLastRow() - 1).setValue(1.0);
    }
  }
  let rowIndex = -1;
  for (let i = 1; i < teamsData.length; i++) {
    if (teamsData[i][0] == teamId) {
      rowIndex = i + 1;
      break;
    }
  }
  if (rowIndex === -1) return createResponse({ error: 'Команда не найдена' }, 404);
  teamsSheet.getRange(rowIndex, beautyCol).setValue(value);
  return createResponse({ success: true, teamId, beautyFactor: value });
}