// ================= КОНФИГУРАЦИЯ =================
const CONFIG = {
  SHEET_ID: '1QmBps1GtJ3WbNFh3spzHCwyBEmK7o7qCFXk1UKqHqVI', // замените на свой
  ADMIN_PASSWORD: 'org2026',
  VERSION: '4.0 (полные стратегии)'
};

// ================= ИНИЦИАЛИЗАЦИЯ ТАБЛИЦ =================
function getSpreadsheet() {
  if (!CONFIG.SHEET_ID) throw new Error('Установите SHEET_ID в конфигурации');
  const ss = SpreadsheetApp.openById(CONFIG.SHEET_ID);
  initializeSheets(ss);
  return ss;
}

function initializeSheets(ss) {
  // Лист команд с дополнительными полями
  let teamsSheet = ss.getSheetByName('teams');
  if (!teamsSheet) {
    teamsSheet = ss.insertSheet('teams');
    teamsSheet.appendRow(['ID', 'Название команды', 'Импульсы', 'Код доступа', 'Контакт', 
                          'Инвестиции', 'Кредит', 'Жетоны', 'Контракт ID', 'Контракт выполнен']);
  } else {
    const headers = teamsSheet.getRange(1, 1, 1, teamsSheet.getLastColumn()).getValues()[0];
    const requiredCols = ['Инвестиции', 'Кредит', 'Жетоны', 'Контракт ID', 'Контракт выполнен'];
    requiredCols.forEach(col => {
      if (!headers.includes(col)) {
        const lastCol = teamsSheet.getLastColumn() + 1;
        teamsSheet.getRange(1, lastCol).setValue(col);
        if (teamsSheet.getLastRow() > 1) {
          teamsSheet.getRange(2, lastCol, teamsSheet.getLastRow() - 1).setValue(0);
        }
      }
    });
  }

  // Лист товаров (все здания из стратегий)
  let itemsSheet = ss.getSheetByName('items');
  if (!itemsSheet) {
    itemsSheet = ss.insertSheet('items');
    itemsSheet.appendRow(['ID', 'Название', 'Описание', 'Цена', 'Иконка', 'Тип', 'Эффект', 'Уникальное']);
    const items = [
      // Индустриальная
      [1, 'Шахта Гелия-3 (малая)', 'Добыча гелия-3', 8, 'fa-solid fa-cube', 'добыча', '{"income":3}', false],
      [2, 'Буровая вышка (глубокая)', 'Добыча воды из-под льда', 10, 'fa-solid fa-water', 'добыча', '{"income":4}', false],
      [3, 'Перерабатывающий завод', 'Удваивает доход всех шахт и буровых', 20, 'fa-solid fa-industry', 'апгрейд', '{"multiplier":"добыча","value":2}', false],
      [4, 'Экспортный терминал', '+1 имп./раунд за каждую шахту', 15, 'fa-solid fa-truck', 'апгрейд', '{"bonusPerUnit":"добыча","amount":1}', false],
      [5, 'Автоматизированный рудник', 'Высокодоходная шахта', 25, 'fa-solid fa-gear', 'добыча', '{"income":8}', false],
      // Технологическая
      [6, 'Солнечная электростанция', 'Энергия солнца', 6, 'fa-solid fa-solar-panel', 'энергия', '{"income":2}', false],
      [7, 'Лаборатория материалов', 'Исследование материалов', 7, 'fa-solid fa-flask', 'наука', '{"income":2}', false],
      [8, 'Термоядерный реактор', 'Удваивает доход всех построек', 22, 'fa-solid fa-atom', 'апгрейд', '{"multiplier":"all","value":2}', false],
      [9, 'Исследовательский центр', '+1 имп./раунд за каждый уникальный тип здания', 18, 'fa-solid fa-microscope', 'наука', '{"bonusPerUnique":1}', false],
      [10, 'Квантовый компьютер', 'Раз в игру: пересчёт дохода раунда ×3', 30, 'fa-solid fa-computer', 'особое', '{"ability":"recompute","multiplier":3}', true],
      // Социальная
      [11, 'Жилой модуль «Комфорт»', 'Жильё для колонистов', 4, 'fa-solid fa-house-chimney', 'жильё', '{"income":1}', false],
      [12, 'Гидропонная ферма', 'Выращивание еды', 5, 'fa-solid fa-leaf', 'ферма', '{"income":2}', false],
      [13, 'Медицинский пункт', 'Забота о здоровье', 6, 'fa-solid fa-hospital', 'социальное', '{"income":2}', false],
      [14, 'Система рециклинга', 'Удваивает доход всех жилых модулей', 12, 'fa-solid fa-recycle', 'апгрейд', '{"multiplier":"жильё","value":2}', false],
      [15, 'Автономная теплица', 'Удваивает доход ферм и +1 за каждую ферму', 15, 'fa-solid fa-seedling', 'апгрейд', '{"multiplier":"ферма","value":2,"bonusPerUnit":"ферма","amount":1}', false],
      [16, 'Культурный центр', '+1 имп./раунд за каждые 2 жилых модуля', 14, 'fa-solid fa-paintbrush', 'социальное', '{"bonusPerN":"жильё","divisor":2,"amount":1}', false],
      [17, 'Рекреационный комплекс', 'Раз в игру: бонус = доходу всех жилых зданий за последний раунд', 20, 'fa-solid fa-tree', 'особое', '{"ability":"recreation"}', true],
      // Сбалансированная
      [18, 'Универсальный модуль', 'Может использоваться как жильё, ферма или лаборатория', 5, 'fa-solid fa-cubes', 'универсальное', '{"income":2,"flexible":true}', false],
      [19, 'Центр управления колонией', '+2 имп./раунд за каждые 3 разных типа зданий', 16, 'fa-solid fa-building', 'управление', '{"bonusPerUniqueTypes":3,"amount":2}', false],
      [20, 'Транспортная сеть', 'Остаток импульсов после раунда не сгорает', 12, 'fa-solid fa-train', 'инфраструктура', '{"carryOver":true}', false],
      [21, 'Биржа ресурсов', 'Инвестиция: 10 имп. → 15 имп. в конце игры', 20, 'fa-solid fa-chart-line', 'финансы', '{"investment":10,"return":15}', false],
      // Спекулятивная
      [22, 'Фонд развития', 'Инвестиция с +50% в конце, если нет кредита', 5, 'fa-solid fa-coins', 'финансы', '{"fund":true,"return":0.5}', false],
      [23, 'Венчурный стартап', 'Случайный исход: 0, 5 или 20 имп.', 10, 'fa-solid fa-dice', 'финансы', '{"gamble":true}', false],
      [24, 'Колониальные облигации', 'Гарантированный доход 2 имп./раунд', 8, 'fa-solid fa-file-invoice', 'финансы', '{"bondIncome":2}', false],
      [25, 'Страховая компания', 'Выплата, если доход ниже среднего', 14, 'fa-solid fa-umbrella', 'финансы', '{"insurance":true}', false],
      [26, 'Кредитный союз', 'Взять кредит до 10 имп. Вернуть 1.5x', 0, 'fa-solid fa-hand-holding-usd', 'финансы', '{"loan":true,"max":10,"repay":1.5}', false],
      // Уникальное здание-рекордсмен
      [27, 'Космический лифт', 'Огромный бонус: +30 имп./раунд, но только одна команда', 50, 'fa-solid fa-elevator', 'уникальное', '{"income":30}', true]
    ];
    items.forEach(row => itemsSheet.appendRow(row));
  }

  // Лист покупок
  if (!ss.getSheetByName('purchases')) {
    const sheet = ss.insertSheet('purchases');
    sheet.appendRow(['ID', 'ID команды', 'ID товара', 'Дата', 'Цена при покупке', 'Статус']);
  } else {
    const sheet = ss.getSheetByName('purchases');
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    if (!headers.includes('Статус')) {
      const lastCol = sheet.getLastColumn() + 1;
      sheet.getRange(1, lastCol).setValue('Статус');
      if (sheet.getLastRow() > 1) {
        const range = sheet.getRange(2, lastCol, sheet.getLastRow() - 1);
        range.setValue('функционирует');
      }
    }
  }

  // Лист транзакций
  if (!ss.getSheetByName('transactions')) {
    const sheet = ss.insertSheet('transactions');
    sheet.appendRow(['Время', 'ID команды', 'Импульсы', 'Причина', 'Кто начислил']);
  }

  // Лист контрактов
  if (!ss.getSheetByName('contracts')) {
    const sheet = ss.insertSheet('contracts');
    sheet.appendRow(['ID', 'Описание', 'Условие (JSON)', 'Награда', 'Активен']);
    const contracts = [
      [1, 'Построить не менее 3 жилых модулей', '{"minCount":{"жильё":3}}', 15, true],
      [2, 'Самый высокий доход от технологий', '{"highest":"наука"}', 20, true],
      [3, 'Не использовать кредиты', '{"noLoan":true}', 10, true],
      [4, 'Иметь минимум 5 разных типов зданий', '{"minUniqueTypes":5}', 25, true]
    ];
    contracts.forEach(row => sheet.appendRow(row));
  }
}

// ================= ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ =================
function getFunctionalBuildingsWithEffects(teamId, ss) {
  const purchasesSheet = ss.getSheetByName('purchases');
  const purchasesData = purchasesSheet.getDataRange().getValues();
  const statusCol = purchasesSheet.getLastColumn();
  const itemsSheet = ss.getSheetByName('items');
  const itemsData = itemsSheet.getDataRange().getValues();
  const itemsMap = {};
  for (let i = 1; i < itemsData.length; i++) {
    itemsMap[itemsData[i][0]] = {
      name: itemsData[i][1],
      type: itemsData[i][5],
      effect: itemsData[i][6] ? JSON.parse(itemsData[i][6]) : {},
      unique: itemsData[i][7] === true
    };
  }

  const buildings = [];
  for (let i = 1; i < purchasesData.length; i++) {
    if (purchasesData[i][1] == teamId && purchasesData[i][statusCol-1] === 'функционирует') {
      const itemId = purchasesData[i][2];
      if (itemsMap[itemId]) {
        buildings.push({
          purchaseId: purchasesData[i][0],
          itemId: itemId,
          ...itemsMap[itemId]
        });
      }
    }
  }
  return buildings;
}

function logTransaction(ss, teamId, points, reason, moderator = 'Система') {
  const transSheet = ss.getSheetByName('transactions');
  transSheet.appendRow([new Date(), teamId, points, reason, moderator]);
}

function updateTeamScore(ss, teamId, delta, reason, moderator = 'Система') {
  const teamsSheet = ss.getSheetByName('teams');
  const teamsData = teamsSheet.getDataRange().getValues();
  for (let i = 1; i < teamsData.length; i++) {
    if (teamsData[i][0] == teamId) {
      const current = parseFloat(teamsData[i][2]) || 0;
      const newScore = current + delta;
      teamsSheet.getRange(i + 1, 3).setValue(newScore);
      logTransaction(ss, teamId, delta, reason, moderator);
      return newScore;
    }
  }
  return null;
}

function createResponse(data, statusCode = 200) {
  return ContentService.createTextOutput(JSON.stringify({
    success: statusCode === 200,
    data: data,
    timestamp: new Date().toISOString(),
    version: CONFIG.VERSION
  })).setMimeType(ContentService.MimeType.JSON);
}

// ================= API GET =================
function doGet(e) {
  try {
    const action = e.parameter.action;
    switch(action) {
      case 'getTeams': return getTeams();
      case 'getTeamByCode': return getTeamByCode(e.parameter.code);
      case 'getTransactions': return getTransactions(e.parameter.teamId);
      case 'getRating': return getRating();
      case 'getShopItems': return getShopItems();
      case 'getTeamInventory': return getTeamInventory(e.parameter.teamId);
      default: return createResponse({ error: 'Неизвестное действие' }, 400);
    }
  } catch (error) {
    return createResponse({ error: error.message }, 500);
  }
}

function getTeams() {
  const ss = getSpreadsheet();
  const teamsSheet = ss.getSheetByName('teams');
  const teamsData = teamsSheet.getDataRange().getValues();
  
  const purchasesSheet = ss.getSheetByName('purchases');
  const purchasesData = purchasesSheet ? purchasesSheet.getDataRange().getValues() : [];
  const teamStats = {};
  
  for (let i = 1; i < purchasesData.length; i++) {
    const teamId = purchasesData[i][1];
    const price = purchasesData[i][4] || 0;
    if (!teamStats[teamId]) teamStats[teamId] = { count: 0, totalSpent: 0 };
    teamStats[teamId].count++;
    teamStats[teamId].totalSpent += price;
  }

  const teams = [];
  for (let i = 1; i < teamsData.length; i++) {
    teams.push({
      id: teamsData[i][0],
      name: teamsData[i][1] || '',
      score: teamsData[i][2] || 0,
      code: teamsData[i][3] || '',
      contact: teamsData[i][4] || '',
      investments: teamsData[i][5] || 0,
      loan: teamsData[i][6] || 0,
      tokens: teamsData[i][7] || '',
      contractId: teamsData[i][8] || null,
      contractDone: teamsData[i][9] || false,
      purchasedCount: teamStats[teamsData[i][0]] ? teamStats[teamsData[i][0]].count : 0,
      totalSpent: teamStats[teamsData[i][0]] ? teamStats[teamsData[i][0]].totalSpent : 0
    });
  }
  return createResponse({ teams });
}

function getTeamByCode(code) {
  const teamsRes = getTeams();
  const teams = JSON.parse(teamsRes.getContent()).data.teams;
  const team = teams.find(t => t.code && t.code.toString().toUpperCase() === code.toString().toUpperCase().trim());
  if (team) return createResponse({ team });
  return createResponse({ error: 'Команда не найдена' }, 404);
}

function getRating() {
  const teamsRes = getTeams();
  const teams = JSON.parse(teamsRes.getContent()).data.teams;
  const sorted = teams.sort((a, b) => (b.score || 0) - (a.score || 0));
  return createResponse({ rating: sorted });
}

function getTransactions(teamId) {
  const ss = getSpreadsheet();
  const sheet = ss.getSheetByName('transactions');
  const data = sheet.getDataRange().getValues();
  const transactions = [];
  for (let i = 1; i < data.length; i++) {
    if (!teamId || data[i][1] == teamId) {
      transactions.push({
        timestamp: data[i][0],
        teamId: data[i][1],
        points: data[i][2],
        reason: data[i][3],
        moderator: data[i][4]
      });
    }
  }
  transactions.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
  return createResponse({ transactions });
}

function getShopItems() {
  const ss = getSpreadsheet();
  const sheet = ss.getSheetByName('items');
  if (!sheet) return createResponse({ items: [] });
  const data = sheet.getDataRange().getValues();
  const items = [];
  for (let i = 1; i < data.length; i++) {
    items.push({
      id: data[i][0],
      name: data[i][1] || '',
      description: data[i][2] || '',
      price: data[i][3] || 0,
      icon: data[i][4] || 'fa-solid fa-question',
      type: data[i][5] || 'общее',
      effect: data[i][6] ? JSON.parse(data[i][6]) : {},
      unique: data[i][7] === true
    });
  }
  return createResponse({ items });
}

function getTeamInventory(teamId) {
  const ss = getSpreadsheet();
  const purchasesSheet = ss.getSheetByName('purchases');
  if (!purchasesSheet) return createResponse({ items: [] });

  const purchasesData = purchasesSheet.getDataRange().getValues();
  const statusCol = purchasesSheet.getLastColumn();
  const purchaseList = [];
  for (let i = 1; i < purchasesData.length; i++) {
    if (purchasesData[i][1] == teamId) {
      purchaseList.push({
        purchaseId: purchasesData[i][0],
        itemId: purchasesData[i][2],
        date: purchasesData[i][3],
        price: purchasesData[i][4],
        status: purchasesData[i][statusCol-1] || 'куплено'
      });
    }
  }

  if (purchaseList.length === 0) return createResponse({ items: [] });

  const itemsSheet = ss.getSheetByName('items');
  const itemsData = itemsSheet.getDataRange().getValues();
  const items = [];
  for (let i = 1; i < itemsData.length; i++) {
    const itemId = itemsData[i][0];
    const purchase = purchaseList.find(p => p.itemId == itemId);
    if (purchase) {
      items.push({
        id: itemId,
        name: itemsData[i][1] || '',
        description: itemsData[i][2] || '',
        price: itemsData[i][3] || 0,
        icon: itemsData[i][4] || 'fa-solid fa-question',
        type: itemsData[i][5] || 'общее',
        effect: itemsData[i][6] ? JSON.parse(itemsData[i][6]) : {},
        unique: itemsData[i][7] === true,
        purchaseId: purchase.purchaseId,
        status: purchase.status
      });
    }
  }
  return createResponse({ items });
}

// ================= API POST =================
function doPost(e) {
  try {
    let data;
    try {
      data = JSON.parse(e.postData.contents);
    } catch (parseError) {
      data = e.parameter;
    }

    const action = data.action;

    // Проверка пароля для организаторских действий
    const adminActions = [
      'addPoints', 'addTeam', 'updateTeam', 'deleteTeam', 
      'addItem', 'updateItem', 'deleteItem', 
      'updatePurchaseStatus', 'processRoundIncome', 'applyEvent', 
      'assignContract', 'checkContract', 'repayLoan'
    ];
    if (adminActions.includes(action)) {
      if (!data.password || data.password !== CONFIG.ADMIN_PASSWORD) {
        return createResponse({ error: 'Неверный пароль организатора' }, 403);
      }
    }

    switch(action) {
      case 'checkPassword': return createResponse({ valid: data.password === CONFIG.ADMIN_PASSWORD });
      case 'addPoints': return addPoints(data);
      case 'addTeam': return addTeam(data);
      case 'updateTeam': return updateTeam(data);
      case 'deleteTeam': return deleteTeam(data);
      case 'addItem': return addItem(data);
      case 'updateItem': return updateItem(data);
      case 'deleteItem': return deleteItem(data);
      case 'buyItem': return buyItem(data);
      case 'updatePurchaseStatus': return updatePurchaseStatus(data);
      case 'processRoundIncome': return processRoundIncome(data);
      case 'applyEvent': return applyEvent(data);
      case 'investInFund': return investInFund(data);
      case 'takeLoan': return takeLoan(data);
      case 'repayLoan': return repayLoan(data);
      case 'activateVenture': return activateVenture(data);
      case 'activateRecreation': return activateRecreation(data);
      case 'activateQuantum': return activateQuantum(data);
      case 'assignContract': return assignContractToTeam(data.teamId);
      case 'checkContract': return checkContract(data.teamId);
      default: return createResponse({ error: 'Неизвестное действие' }, 400);
    }
  } catch (error) {
    return createResponse({ error: error.message }, 500);
  }
}

// ================= ОСНОВНЫЕ ФУНКЦИИ =================
function addPoints(data) {
  const teamId = parseInt(data.teamId);
  const points = parseInt(data.points);
  const reason = data.reason || '';
  const moderator = data.moderator || 'Организатор';
  const ss = getSpreadsheet();
  const newScore = updateTeamScore(ss, teamId, points, reason, moderator);
  if (newScore === null) return createResponse({ error: 'Команда не найдена' }, 404);
  return createResponse({ success: true, newScore });
}

function addTeam(data) {
  const name = data.name;
  const code = data.code.toUpperCase();
  const contact = data.contact || '';
  const ss = getSpreadsheet();
  const sheet = ss.getSheetByName('teams');
  const teamsData = sheet.getDataRange().getValues();
  for (let i = 1; i < teamsData.length; i++) {
    if (teamsData[i][3] && teamsData[i][3].toString().toUpperCase() === code) {
      return createResponse({ error: 'Код уже используется' }, 400);
    }
  }
  let maxId = 0;
  for (let i = 1; i < teamsData.length; i++) maxId = Math.max(maxId, parseInt(teamsData[i][0]) || 0);
  const newId = maxId + 1;
  sheet.appendRow([newId, name, 0, code, contact, 0, 0, '', null, false]);
  return createResponse({ success: true, team: { id: newId, name, score: 0, code, contact } });
}

function updateTeam(data) {
  const teamId = parseInt(data.teamId);
  const name = data.name;
  const code = data.code.toUpperCase();
  const contact = data.contact || '';
  const ss = getSpreadsheet();
  const sheet = ss.getSheetByName('teams');
  const teamsData = sheet.getDataRange().getValues();
  let rowIndex = -1;
  for (let i = 1; i < teamsData.length; i++) {
    if (teamsData[i][0] == teamId) { rowIndex = i + 1; break; }
  }
  if (rowIndex === -1) return createResponse({ error: 'Команда не найдена' }, 404);
  const oldCode = teamsData[rowIndex-1][3];
  if (code !== oldCode) {
    for (let i = 1; i < teamsData.length; i++) {
      if (i !== rowIndex-1 && teamsData[i][3] && teamsData[i][3].toString().toUpperCase() === code) {
        return createResponse({ error: 'Код уже используется' }, 400);
      }
    }
  }
  sheet.getRange(rowIndex, 2).setValue(name);
  sheet.getRange(rowIndex, 4).setValue(code);
  sheet.getRange(rowIndex, 5).setValue(contact);
  return createResponse({ success: true });
}

function deleteTeam(data) {
  const teamId = parseInt(data.teamId);
  const ss = getSpreadsheet();
  const sheet = ss.getSheetByName('teams');
  const teamsData = sheet.getDataRange().getValues();
  let rowIndex = -1;
  for (let i = 1; i < teamsData.length; i++) {
    if (teamsData[i][0] == teamId) { rowIndex = i + 1; break; }
  }
  if (rowIndex === -1) return createResponse({ error: 'Команда не найдена' }, 404);
  sheet.deleteRow(rowIndex);

  // Удаляем связанные транзакции и покупки
  const transSheet = ss.getSheetByName('transactions');
  const transData = transSheet.getDataRange().getValues();
  for (let i = transData.length - 1; i >= 1; i--) {
    if (transData[i][1] == teamId) transSheet.deleteRow(i + 1);
  }
  const purchasesSheet = ss.getSheetByName('purchases');
  const purchasesData = purchasesSheet.getDataRange().getValues();
  for (let i = purchasesData.length - 1; i >= 1; i--) {
    if (purchasesData[i][1] == teamId) purchasesSheet.deleteRow(i + 1);
  }
  return createResponse({ success: true });
}

function addItem(data) {
  const name = data.name;
  const description = data.description || '';
  const price = parseInt(data.price) || 0;
  const icon = data.icon || 'fa-solid fa-question';
  const type = data.type || 'общее';
  const effect = data.effect || '{}';
  const unique = data.unique === 'true' || data.unique === true;
  const ss = getSpreadsheet();
  const sheet = ss.getSheetByName('items');
  const itemsData = sheet.getDataRange().getValues();
  let maxId = 0;
  for (let i = 1; i < itemsData.length; i++) maxId = Math.max(maxId, parseInt(itemsData[i][0]) || 0);
  const newId = maxId + 1;
  sheet.appendRow([newId, name, description, price, icon, type, effect, unique]);
  return createResponse({ success: true, item: { id: newId, name, description, price, icon, type, effect, unique } });
}

function updateItem(data) {
  const itemId = parseInt(data.itemId);
  const name = data.name;
  const description = data.description || '';
  const price = parseInt(data.price) || 0;
  const icon = data.icon || 'fa-solid fa-question';
  const type = data.type || 'общее';
  const effect = data.effect || '{}';
  const unique = data.unique === 'true' || data.unique === true;
  const ss = getSpreadsheet();
  const sheet = ss.getSheetByName('items');
  const itemsData = sheet.getDataRange().getValues();
  let rowIndex = -1;
  for (let i = 1; i < itemsData.length; i++) {
    if (itemsData[i][0] == itemId) { rowIndex = i + 1; break; }
  }
  if (rowIndex === -1) return createResponse({ error: 'Товар не найден' }, 404);
  sheet.getRange(rowIndex, 2).setValue(name);
  sheet.getRange(rowIndex, 3).setValue(description);
  sheet.getRange(rowIndex, 4).setValue(price);
  sheet.getRange(rowIndex, 5).setValue(icon);
  sheet.getRange(rowIndex, 6).setValue(type);
  sheet.getRange(rowIndex, 7).setValue(effect);
  sheet.getRange(rowIndex, 8).setValue(unique);
  return createResponse({ success: true });
}

function deleteItem(data) {
  const itemId = parseInt(data.itemId);
  const ss = getSpreadsheet();
  const sheet = ss.getSheetByName('items');
  const itemsData = sheet.getDataRange().getValues();
  let rowIndex = -1;
  for (let i = 1; i < itemsData.length; i++) {
    if (itemsData[i][0] == itemId) { rowIndex = i + 1; break; }
  }
  if (rowIndex === -1) return createResponse({ error: 'Товар не найден' }, 404);
  sheet.deleteRow(rowIndex);
  // Удаляем связанные покупки
  const purchasesSheet = ss.getSheetByName('purchases');
  const purchasesData = purchasesSheet.getDataRange().getValues();
  for (let i = purchasesData.length - 1; i >= 1; i--) {
    if (purchasesData[i][2] == itemId) purchasesSheet.deleteRow(i + 1);
  }
  return createResponse({ success: true });
}

function buyItem(data) {
  const teamId = parseInt(data.teamId);
  const itemId = parseInt(data.itemId);
  const ss = getSpreadsheet();

  // Проверка уникальности здания
  const itemsSheet = ss.getSheetByName('items');
  const itemsData = itemsSheet.getDataRange().getValues();
  let itemPrice = 0, itemName = '', itemUnique = false;
  for (let i = 1; i < itemsData.length; i++) {
    if (itemsData[i][0] == itemId) {
      itemPrice = parseFloat(itemsData[i][3]) || 0;
      itemName = itemsData[i][1] || '';
      itemUnique = itemsData[i][7] === true;
      break;
    }
  }
  if (itemPrice === 0) return createResponse({ error: 'Товар не найден' }, 404);

  if (itemUnique) {
    // Проверяем, не купил ли уже кто-то это уникальное здание
    const purchasesSheet = ss.getSheetByName('purchases');
    const purchasesData = purchasesSheet.getDataRange().getValues();
    for (let i = 1; i < purchasesData.length; i++) {
      if (purchasesData[i][2] == itemId) {
        return createResponse({ error: 'Это уникальное здание уже куплено другой командой' }, 400);
      }
    }
  }

  // Проверка баланса команды
  const teamsSheet = ss.getSheetByName('teams');
  const teamsData = teamsSheet.getDataRange().getValues();
  let teamRow = -1, teamScore = 0;
  for (let i = 1; i < teamsData.length; i++) {
    if (teamsData[i][0] == teamId) {
      teamRow = i + 1;
      teamScore = parseFloat(teamsData[i][2]) || 0;
      break;
    }
  }
  if (teamRow === -1) return createResponse({ error: 'Команда не найдена' }, 404);
  if (teamScore < itemPrice) return createResponse({ error: 'Недостаточно импульсов' }, 400);

  // Списание импульсов
  const newScore = teamScore - itemPrice;
  teamsSheet.getRange(teamRow, 3).setValue(newScore);

  // Запись покупки со статусом "строится"
  const purchasesSheet = ss.getSheetByName('purchases');
  const purchasesData = purchasesSheet.getDataRange().getValues();
  let maxPurchaseId = 0;
  for (let i = 1; i < purchasesData.length; i++) {
    maxPurchaseId = Math.max(maxPurchaseId, parseInt(purchasesData[i][0]) || 0);
  }
  const newPurchaseId = maxPurchaseId + 1;
  const statusCol = purchasesSheet.getLastColumn();
  purchasesSheet.appendRow([newPurchaseId, teamId, itemId, new Date(), itemPrice, 'строится']);

  logTransaction(ss, teamId, -itemPrice, `Покупка: ${itemName}`, 'Команда');

  return createResponse({ success: true, newScore, item: { id: itemId, name: itemName, price: itemPrice } });
}

function updatePurchaseStatus(data) {
  const purchaseId = parseInt(data.purchaseId);
  const newStatus = data.status;
  const ss = getSpreadsheet();
  const sheet = ss.getSheetByName('purchases');
  const purchasesData = sheet.getDataRange().getValues();
  let rowIndex = -1;
  for (let i = 1; i < purchasesData.length; i++) {
    if (purchasesData[i][0] == purchaseId) { rowIndex = i + 1; break; }
  }
  if (rowIndex === -1) return createResponse({ error: 'Покупка не найдена' }, 404);
  const statusCol = sheet.getLastColumn();
  sheet.getRange(rowIndex, statusCol).setValue(newStatus);
  return createResponse({ success: true, newStatus });
}

function processRoundIncome(data) {
  const ss = getSpreadsheet();
  const teamsSheet = ss.getSheetByName('teams');
  const teamsData = teamsSheet.getDataRange().getValues();
  
  for (let i = 1; i < teamsData.length; i++) {
    const teamId = teamsData[i][0];
    const buildings = getFunctionalBuildingsWithEffects(teamId, ss);
    
    let baseIncome = 0;
    const typeCounts = {};
    const uniqueTypes = new Set();
    let bondIncome = 0;
    let perUnitBonus = 0;

    buildings.forEach(b => {
      const eff = b.effect;
      if (b.type) {
        typeCounts[b.type] = (typeCounts[b.type] || 0) + 1;
        uniqueTypes.add(b.type);
      }
      if (eff.income) baseIncome += eff.income;
      if (eff.bondIncome) bondIncome += eff.bondIncome;
    });

    // Множители
    let multiplier = 1;
    buildings.forEach(b => {
      const eff = b.effect;
      if (eff.multiplier) {
        if (eff.multiplier === 'all') {
          multiplier *= eff.value;
        } else {
          if (typeCounts[eff.multiplier] && typeCounts[eff.multiplier] > 0) {
            multiplier *= eff.value;
          }
        }
      }
    });

    // Бонусы per unit
    buildings.forEach(b => {
      const eff = b.effect;
      if (eff.bonusPerUnit) {
        const count = typeCounts[eff.bonusPerUnit] || 0;
        perUnitBonus += count * (eff.amount || 1);
      }
      if (eff.bonusPerN) {
        const count = typeCounts[eff.bonusPerN] || 0;
        perUnitBonus += Math.floor(count / (eff.divisor || 1)) * (eff.amount || 1);
      }
      if (eff.bonusPerUnique) {
        perUnitBonus += uniqueTypes.size * eff.bonusPerUnique;
      }
      if (eff.bonusPerUniqueTypes) {
        const groups = Math.floor(uniqueTypes.size / eff.bonusPerUniqueTypes);
        perUnitBonus += groups * (eff.amount || 2);
      }
    });

    let totalIncome = Math.round((baseIncome + bondIncome + perUnitBonus) * multiplier);

    if (totalIncome !== 0) {
      updateTeamScore(ss, teamId, totalIncome, 'Доход за раунд', 'Система');
    }
  }

  return createResponse({ success: true, message: 'Доход начислен' });
}

function applyEvent(data) {
  const eventType = data.eventType;
  const ss = getSpreadsheet();
  const teamsSheet = ss.getSheetByName('teams');
  const teamsData = teamsSheet.getDataRange().getValues();

  switch (eventType) {
    case 'meteor':
      for (let i = 1; i < teamsData.length; i++) {
        const teamId = teamsData[i][0];
        const buildings = getFunctionalBuildingsWithEffects(teamId, ss);
        const hasShield = buildings.some(b => b.effect.shield === true);
        if (!hasShield) {
          const current = parseFloat(teamsData[i][2]) || 0;
          const loss = Math.round(current * 0.2);
          if (loss > 0) {
            updateTeamScore(ss, teamId, -loss, 'Метеоритный дождь (нет щита)', 'Событие');
          }
        }
      }
      break;

    case 'solarFlare':
      for (let i = 1; i < teamsData.length; i++) {
        const teamId = teamsData[i][0];
        const buildings = getFunctionalBuildingsWithEffects(teamId, ss);
        let energyIncome = 0;
        buildings.forEach(b => {
          if (b.type === 'энергия' && b.effect.income) energyIncome += b.effect.income;
        });
        if (energyIncome > 0) {
          updateTeamScore(ss, teamId, -energyIncome, 'Солнечная буря (энергия отключена)', 'Событие');
        }
      }
      break;

    case 'resourceBoost':
      for (let i = 1; i < teamsData.length; i++) {
        const teamId = teamsData[i][0];
        const buildings = getFunctionalBuildingsWithEffects(teamId, ss);
        let miningIncome = 0;
        buildings.forEach(b => {
          if (b.type === 'добыча' && b.effect.income) miningIncome += b.effect.income;
        });
        if (miningIncome > 0) {
          updateTeamScore(ss, teamId, miningIncome, 'Ресурсный бум (+100% добыча)', 'Событие');
        }
      }
      break;

    default:
      return createResponse({ error: 'Неизвестное событие' }, 400);
  }

  return createResponse({ success: true, message: `Событие ${eventType} применено` });
}

function investInFund(data) {
  const teamId = parseInt(data.teamId);
  const amount = parseInt(data.amount);
  if (amount < 5) return createResponse({ error: 'Минимальная инвестиция 5' }, 400);

  const ss = getSpreadsheet();
  const teamsSheet = ss.getSheetByName('teams');
  const teamsData = teamsSheet.getDataRange().getValues();
  let teamRow = -1, currentScore = 0, investments = 0;
  for (let i = 1; i < teamsData.length; i++) {
    if (teamsData[i][0] == teamId) {
      teamRow = i + 1;
      currentScore = parseFloat(teamsData[i][2]) || 0;
      investments = parseFloat(teamsData[i][5]) || 0;
      break;
    }
  }
  if (teamRow === -1) return createResponse({ error: 'Команда не найдена' }, 404);
  if (currentScore < amount) return createResponse({ error: 'Недостаточно импульсов' }, 400);

  const newScore = currentScore - amount;
  teamsSheet.getRange(teamRow, 3).setValue(newScore);
  teamsSheet.getRange(teamRow, 6).setValue(investments + amount);
  logTransaction(ss, teamId, -amount, 'Инвестиция в фонд', 'Команда');

  return createResponse({ success: true, newScore, totalInvested: investments + amount });
}

function takeLoan(data) {
  const teamId = parseInt(data.teamId);
  const amount = parseInt(data.amount);
  if (amount < 1 || amount > 10) return createResponse({ error: 'Сумма кредита от 1 до 10' }, 400);

  const ss = getSpreadsheet();
  const teamsSheet = ss.getSheetByName('teams');
  const teamsData = teamsSheet.getDataRange().getValues();
  let teamRow = -1, currentScore = 0, loan = 0;
  for (let i = 1; i < teamsData.length; i++) {
    if (teamsData[i][0] == teamId) {
      teamRow = i + 1;
      currentScore = parseFloat(teamsData[i][2]) || 0;
      loan = parseFloat(teamsData[i][6]) || 0;
      break;
    }
  }
  if (teamRow === -1) return createResponse({ error: 'Команда не найдена' }, 404);
  if (loan > 0) return createResponse({ error: 'У команды уже есть кредит' }, 400);

  const newScore = currentScore + amount;
  teamsSheet.getRange(teamRow, 3).setValue(newScore);
  teamsSheet.getRange(teamRow, 7).setValue(amount);
  logTransaction(ss, teamId, amount, 'Кредит получен', 'Команда');

  return createResponse({ success: true, newScore, loan: amount });
}

function repayLoan(data) {
  const teamId = parseInt(data.teamId);
  const ss = getSpreadsheet();
  const teamsSheet = ss.getSheetByName('teams');
  const teamsData = teamsSheet.getDataRange().getValues();
  let teamRow = -1, currentScore = 0, loan = 0;
  for (let i = 1; i < teamsData.length; i++) {
    if (teamsData[i][0] == teamId) {
      teamRow = i + 1;
      currentScore = parseFloat(teamsData[i][2]) || 0;
      loan = parseFloat(teamsData[i][6]) || 0;
      break;
    }
  }
  if (teamRow === -1) return createResponse({ error: 'Команда не найдена' }, 404);
  if (loan === 0) return createResponse({ error: 'Нет кредита' }, 400);

  const repayAmount = Math.ceil(loan * 1.5);
  if (currentScore < repayAmount) return createResponse({ error: 'Недостаточно импульсов для погашения' }, 400);

  const newScore = currentScore - repayAmount;
  teamsSheet.getRange(teamRow, 3).setValue(newScore);
  teamsSheet.getRange(teamRow, 7).setValue(0);
  logTransaction(ss, teamId, -repayAmount, 'Погашение кредита (150%)', 'Система');

  return createResponse({ success: true, newScore });
}

function activateVenture(data) {
  const teamId = parseInt(data.teamId);
  const purchaseId = parseInt(data.purchaseId);
  const ss = getSpreadsheet();
  const buildings = getFunctionalBuildingsWithEffects(teamId, ss);
  const venture = buildings.find(b => b.purchaseId == purchaseId && b.effect.gamble);
  if (!venture) return createResponse({ error: 'Стартап не найден или не функционирует' }, 404);

  const rand = Math.random();
  let gain = 0;
  if (rand < 0.33) gain = 0;
  else if (rand < 0.66) gain = 5;
  else gain = 20;

  if (gain > 0) {
    updateTeamScore(ss, teamId, gain, 'Венчурный стартап: успех', 'Событие');
  } else {
    logTransaction(ss, teamId, 0, 'Венчурный стартап: провал', 'Событие');
  }

  // Можно пометить стартап как использованный (изменить статус или удалить)
  return createResponse({ success: true, gain });
}

function activateRecreation(data) {
  const teamId = parseInt(data.teamId);
  const purchaseId = parseInt(data.purchaseId);
  const ss = getSpreadsheet();
  const buildings = getFunctionalBuildingsWithEffects(teamId, ss);
  const rec = buildings.find(b => b.purchaseId == purchaseId && b.effect.ability === 'recreation');
  if (!rec) return createResponse({ error: 'Комплекс не найден' }, 404);

  let жильёIncome = 0;
  buildings.forEach(b => {
    if (b.type === 'жильё' && b.effect.income) жильёIncome += b.effect.income;
  });
  if (жильёIncome > 0) {
    updateTeamScore(ss, teamId, жильёIncome, 'Рекреационный комплекс', 'Активация');
  }
  return createResponse({ success: true, bonus: жильёIncome });
}

function activateQuantum(data) {
  // Заглушка
  return createResponse({ success: true, message: 'Функция в разработке' });
}

function assignContractToTeam(teamId) {
  const ss = getSpreadsheet();
  const contractsSheet = ss.getSheetByName('contracts');
  const contractsData = contractsSheet.getDataRange().getValues();
  const activeContracts = [];
  for (let i = 1; i < contractsData.length; i++) {
    if (contractsData[i][4] === true) activeContracts.push({
      id: contractsData[i][0],
      desc: contractsData[i][1],
      condition: JSON.parse(contractsData[i][2]),
      reward: contractsData[i][3]
    });
  }
  if (activeContracts.length === 0) return createResponse({ error: 'Нет доступных контрактов' }, 400);
  const randomIndex = Math.floor(Math.random() * activeContracts.length);
  const contract = activeContracts[randomIndex];

  const teamsSheet = ss.getSheetByName('teams');
  const teamsData = teamsSheet.getDataRange().getValues();
  for (let i = 1; i < teamsData.length; i++) {
    if (teamsData[i][0] == teamId) {
      teamsSheet.getRange(i + 1, 9).setValue(contract.id);  // Контракт ID
      teamsSheet.getRange(i + 1, 10).setValue(false);       // Контракт выполнен
      break;
    }
  }
  return createResponse({ success: true, contract });
}

function checkContract(teamId) {
  const ss = getSpreadsheet();
  const teamsSheet = ss.getSheetByName('teams');
  const teamsData = teamsSheet.getDataRange().getValues();
  let teamRow = -1, contractId = null, completed = false;
  for (let i = 1; i < teamsData.length; i++) {
    if (teamsData[i][0] == teamId) {
      teamRow = i + 1;
      contractId = teamsData[i][8];
      completed = teamsData[i][9];
      break;
    }
  }
  if (!contractId || completed) return createResponse({ error: 'Нет активного контракта или уже выполнен' }, 400);

  const contractsSheet = ss.getSheetByName('contracts');
  const contractsData = contractsSheet.getDataRange().getValues();
  let contract = null;
  for (let i = 1; i < contractsData.length; i++) {
    if (contractsData[i][0] == contractId) {
      contract = {
        condition: JSON.parse(contractsData[i][2]),
        reward: contractsData[i][3]
      };
      break;
    }
  }
  if (!contract) return createResponse({ error: 'Контракт не найден' }, 404);

  const buildings = getFunctionalBuildingsWithEffects(teamId, ss);
  const typeCounts = {};
  const uniqueTypes = new Set();
  buildings.forEach(b => {
    if (b.type) {
      typeCounts[b.type] = (typeCounts[b.type] || 0) + 1;
      uniqueTypes.add(b.type);
    }
  });

  let conditionMet = false;
  const cond = contract.condition;
  if (cond.minCount) {
    conditionMet = true;
    for (let type in cond.minCount) {
      if ((typeCounts[type] || 0) < cond.minCount[type]) {
        conditionMet = false;
        break;
      }
    }
  } else if (cond.noLoan) {
    const loan = teamsData[teamRow-1][6] || 0;
    conditionMet = (loan === 0);
  } else if (cond.minUniqueTypes) {
    conditionMet = (uniqueTypes.size >= cond.minUniqueTypes);
  }

  if (conditionMet) {
    updateTeamScore(ss, teamId, contract.reward, 'Выполнение контракта', 'Система');
    teamsSheet.getRange(teamRow, 10).setValue(true);
    return createResponse({ success: true, reward: contract.reward });
  } else {
    return createResponse({ success: false, message: 'Условие не выполнено' });
  }
}